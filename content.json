[{"title":"多线程","date":"2017-05-17T06:34:41.000Z","path":"2017/05/17/多线程/","text":"NSThread一个NSThread对象就代表一条线程123456789101112131415NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start];// 线程一启动，就会在线程thread中执行self的run方法主线程相关用法+ (NSThread *)mainThread; // 获得主线程- (BOOL)isMainThread; // 是否为主线程+ (BOOL)isMainThread; // 是否为主线程获得当前线程NSThread *current = [NSThread currentThread];线程的名字- (void)setName:(NSString *)n;- (NSString *)name; 其他创建线程方式1234567创建线程后自动启动线程[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];隐式创建并启动线程[self performSelectorInBackground:@selector(run) withObject:nil];上述2种创建线程方式的优缺点优点：简单快捷缺点：无法对线程进行更详细的设置 控制线程状态1234567891011121314启动线程- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态阻塞（暂停）线程+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态强制停止线程+ (void)exit;// 进入死亡状态注意：一旦线程停止（死亡）了，就不能再次开启任务 线程间通信12- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; NSOperation配合使用NSOperation和NSOperationQueue也能实现多线程编程,具体方式：先将需要执行的操作封装到一个NSOperation对象中然后将NSOperation对象添加到NSOperationQueue中系统会自动将NSOperationQueue中的NSOperation取出来将取出的NSOperation封装的操作放到一条新线程中执行 NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种NSInvocationOperation12345678创建NSInvocationOperation对象- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法注意:默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作,只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation1234567创建NSBlockOperation对象+ (id)blockOperationWithBlock:(void (^)(void))block;通过addExecutionBlock:方法添加更多的操作- (void)addExecutionBlock:(void (^)(void))block;注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 自定义子类继承NSOperation，实现内部相应的方法123456自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 NSOperationQueue的作用NSOperation可以调用start方法来执行任务，但默认是同步执行的如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作123添加操作到NSOperationQueue中- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; 最大并发数的相关方法(并发数:同时执行的任务数)12- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消、暂停、恢复1234567取消队列的所有操作- (void)cancelAllOperations;也可以调用NSOperation的- (void)cancel方法取消单个操作暂停和恢复队列- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序,但不能相互依赖12比如一定要让操作A执行完后，才能执行操作B，可以这么写[operationB addDependency:operationA]; // 操作B依赖于操作A 操作的监听123可以监听一个操作的执行完毕- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"自定义控制器","date":"2017-05-16T08:57:42.000Z","path":"2017/05/16/自定义控制器/","text":"如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系 自定义控制器（带转场动画）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;XMGOneViewController.h&quot;#import &quot;XMGTwoViewController.h&quot;#import &quot;XMGThreeViewController.h&quot;@interface ViewController ()/** 正在显示的控制器 */@property (nonatomic, weak) UIViewController *showingVc;@end@implementation ViewController/** 如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系[a.view addSubview:b.view];[a addChildViewController:b];或者[a.view addSubview:otherView];[otherView addSubbiew.b.view];[a addChildViewController:b]; */- (void)viewDidLoad &#123; [super viewDidLoad]; // 通过addChildViewController添加的控制器都会存在于childViewControllers数组中 [self addChildViewController:[[XMGOneViewController alloc] init]]; [self addChildViewController:[[XMGTwoViewController alloc] init]]; [self addChildViewController:[[XMGThreeViewController alloc] init]];&#125;- (IBAction)buttonClick:(UIButton *)button &#123; // 移除其他控制器的view [self.showingVc.view removeFromSuperview]; // 获得控制器的位置（索引） NSUInteger index = [button.superview.subviews indexOfObject:button]; // 当前控制器的索引 NSUInteger oldIndex = [self.childViewControllers indexOfObject:self.showingVc]; // 添加控制器的view self.showingVc = self.childViewControllers[index]; self.showingVc.view.frame = self.contentView.bounds; [self.contentView addSubview:self.showingVc.view]; // 动画 CATransition *animation = [CATransition animation]; animation.type = @&quot;cube&quot;; animation.subtype = index &gt; oldIndex ? kCATransitionFromRight : kCATransitionFromLeft; animation.duration = 0.5; [self.contentView.layer addAnimation:animation forKey:nil];&#125;/** * 屏幕即将旋转到某个方向时会调用这个方法 */- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration&#123; NSLog(@&quot;%@ willRotateToInterfaceOrientation&quot;, self.class);&#125;@end 级联菜单型的控制器（类似多个相关滚轮选择）的实现：在容器里添加多个子控制器，然后在子控制器之间可以通过代理传递关联关系也可以选择使用多个tableView实现","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"ScrollView中控件悬停和拉伸图片","date":"2017-05-16T08:33:55.000Z","path":"2017/05/16/ScrollView中控件悬停和拉伸图片/","text":"实际开发中有时会需要用到随着拖动视图上部的image会出现拉伸效果，而下面的控件位置不动的情况。可通过监听scrollView滚动来实现123456789101112131415161718192021222324#pragma mark - &lt;UIScrollViewDelegate&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat imageH = self.imageView.frame.size.height; CGFloat offsetY = scrollView.contentOffset.y; NSLog(@&quot;%f&quot;,scrollView.contentOffset.y); if (offsetY &gt;= imageH) &#123; // 将静止的控件添加到控制器的view中，设置Y值为0 CGRect staticF = self.redView.frame; staticF.origin.y = 0; self.staticView.frame = staticF; [self.view addSubview:self.staticView]; &#125; else &#123; // 将红色控件添加到scrollView中，设置Y值为图片的高度 CGRect staticF = self.staticView.frame; staticF.origin.y = 140; self.staticView.frame = staticF; [self.scrollView addSubview:self.staticView]; &#125; CGFloat scale = 1 - (offsetY / 70); scale = (scale &gt;= 1) ? scale : 1; //图片拉伸 self.imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"CodeSnippets","date":"2017-03-27T06:25:22.000Z","path":"2017/03/27/CodeSnippets/","text":"利用Code Snippets可以提高工作效率，而且Code Snippets可以在不同设备之间移动。Xcode中的Code Snippets默认放在下面的目录中：~/Library/Developer/Xcode/UserData/CodeSnippets 定义自己的Code Snippets1.先写好代码片段，占位符的生成语法：&lt;#占位符#&gt;2.将代码片段拖入Xcode右侧代码片段区3.编辑好代码片段信息4.使用（可以通过拖拽和快捷方式使用）","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"masonry","date":"2017-03-27T03:48:28.000Z","path":"2017/03/27/masonry/","text":"把masonry框架载入工程后，请把以下两句宏定义写到头文件内，以便省略该框架语句的“mas_”前缀12#define MAS_SHORTHAND#define MAS_SHORTHAND_GLOBALS约束关系123.equalTo : = (对应NSLayoutRelationEqual) .lessThanOrEqualTo : &lt;= (对应NSLayoutRelationLessThanOrEqual) .greaterThanOrEqualTo : &gt;= (对应NSLayoutRelationGreaterThanOrEqual)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS简单动画","date":"2017-03-20T02:47:09.000Z","path":"2017/03/20/iOS动画/","text":"三种简单动画 首尾动画简单介绍首尾式动画效果（1）开始动画（2）设置动画相关的时间等（3）参与动画的行动（4）提交动画1234567891011[UIView beginAnimations:nil context:nil];//beginAnimations表示此后的代码要“参与到”动画中[UIView setAnimationDuration:2.0];self.headImageView.bounds = rect;// self.headImageView.alpha = 0; ...... setAnimationDuration用来指定动画持续时间[UIView commitAnimations];commitAnimations,将beginAnimation之后的所有动画提交并生成动画 block动画12345[UIView animateWithDuration:0.4 animations:^&#123; //添加动画 &#125; completion:^(BOOL finished) &#123; //动画结束后执行的操作 &#125;]; 序列帧动画12345678//设置动画数组[self.tom setAnimationImages:arrayM];//设置动画播放次数[self.tom setAnimationRepeatCount:1];//设置动画播放时间[self.tom setAnimationDuration:40*0.075];//开始动画[self.tom startAnimating];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Quartz2D","date":"2017-03-20T01:42:33.000Z","path":"2017/03/20/Quartz2D/","text":"Quartz2D(二维绘图引擎),用途：绘制图形、绘制文字、绘制和生成图片（图像）、读取和生成PDF、截图和裁剪图片、自定义UI控件…Quartz2D提供以下几种类型的Graphics Context：Bitmap Graphics ContextPDF Graphics ContextWindow Graphics ContextLayer Graphics ContextPrinter Graphics Context 例：使用Quartz2D自定义view12341.新建一个view，继承自UIView2.实现-(void)drawRect:(CGRect)rect方法，然后在这个方法中先取到跟当前view相关联的图形上下文，然后绘制相应的图形内容，再利用图形上下文将绘制的所有内容渲染显示到view上面注意：-(void)drawrect:(CGRect)rect方法会在view要显示的时候调用，在viewDidLoad,viewWillAppear方法后，viewDidAppear方法前调用;在每次刷新界面时调用，手动调用无效；若要调用该方法，需使用setNeedsDisplay（重绘，全屏）或setNeedsDisplayInRect:(重绘，指定区域)方法。方法一：最根本的方法，其他是在本方法上的简化123456789101112131415161718-(void)drawrect:(CGRect)rect &#123;//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径CGMutablePathRef path = CGPathCreatMutable();//设置起点CGPathMoveToPoint(path,NULL,50,50);(路径，形变，x，y)添加一条线的另一个点CGPathAddLineToPoint(path,NULL,100,100); //3.把路径添加到上下文CGContextAddPath(ctx,path);//4.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法二：对方法一的简化1234567891011121314-(void)drawrect:(CGRect)rect &#123;//rect是控件的bounds//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径//设置起点CGContextMoveToPoint(ctx,50,50);添加一条线的另一个点CGContextAddLineToPoint(ctx,100,100);//3.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法三：贝瑟尔路径（UIKit对Quartz2D的封装）1234567891011-(void)drawrect:(CGRect)rect &#123;//贝瑟尔路径//创建路径UIBezierPath *path = [UIBezierPath bezierPath];//设置起点[path moveToPoint:CGPointMake(50,50)];//设置另一点[path addLineToPoint:CGPointMake(100,100)];//绘制路径[path stroke];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"RunLoop","date":"2017-03-16T01:29:41.000Z","path":"2017/03/16/RunLoop/","text":"一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出这种模型通常被称作 Event Loop(事件循环)。RunLoop是iOS中的Event Loop。Runloop下面有多种模式(Mode)，但是同一时间下只有一种模式可以运行，处理当前模式下事件。Cocoa中的预定义模式有: Default模式：NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)，默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。 Connection模式：NSConnectionReplyMode(Cocoa)，处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。 Modal模式：NSModalPanelRunLoopMode(Cocoa)，处理modal panels事件。 Event tracking模式：UITrackingRunLoopMode(iOS) NSEventTrackingRunLoopMode(cocoa)，描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。 Common模式：NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)，这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。 Mode下包含Source（事件源）、Observer（观察者：监听runloop的状态改变）、Timer（定时器） RunLoop内部逻辑","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"文件下载","date":"2017-03-15T02:36:16.000Z","path":"2017/03/15/文件下载/","text":"HEAD请求：请求头信息，并不返回请求数据体，而只返回请求头信息，常用用于在文件下载中取得文件大小、类型等信息。1234NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:2.0f];//HEAD头(返回文件资源的信息，不返回具体数据)//如果要获取资源的MIMEType，也必须用HEAD，否则，数据会重复下载两次request.HTTPMethod = @&quot;HEAD&quot;;针对文件的分段下载，要先通过HEAD请求获取到文件的信息，让后才能分段下载123456789101112可以通过Range指定每次从网路下载的数据包的大小示例：bytes = 0-499 从0到499的头500个字节bytes = 500-999 从500到999的第二个500字节bytes = 500- 从500字节以后的所有字节bytes = -500 最后500个字节bytes = 500-599,800-899 同时指定几个范围NSString *range = [NSString stringWithFormat:@&quot;Bytes=%lld-%lld&quot;,0,499];NSMutableURLRequest *request= [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:5.0f]; //通过请求头设置数据请求范围.要对请求进行操作,肯定要对请求头做操作! [request setValue:range forHTTPHeaderField:@&quot;Range&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"手势识别","date":"2017-03-14T07:18:16.000Z","path":"2017/03/14/手势识别/","text":"iOS开发中基本手势有六种：点击手势（TapGestureRecognizer）,滑动手势 （SwipeGestureRecognizer）是用于监测滑动的方向的，移动速度快,拖动手势（PanGestureRecognizer）是用于监测偏移的量的，移动速度慢,捏合手势（PinchGestureRecognizer）,旋转手势（RotationGestureRecognizer）,长按手势（LongPressGestureRecognizer）。注意:1.一个手势一般只能对应一个view，但同一个view可以添加多个手势;若要实现一个手势控制多个view，要实现其代理（UIGuidedAccessRestrictionDelegate）,把self作为代理设置给手势 longGesture.delegate = self;，并实现1234-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;2.手势识别是互斥的，比如单击和双击，如果它识别出一种手势，其后的手势将不被识别。所以在添加手势时使用[A requireGestureRecognizerToFail：B]函数，它可以指定当A手势发生时，即便A已经滿足条件了，也不会立刻触发，会等到指定的手势B确定失败之后才触发。1234567891011121314151617181920212223242526272829303132333435363738//点击手势UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapAction:)];//点击次数设置tapGesture.numberOfTapsRequired = 2;//点击手指数目设置tapGesture.numberOfTouchesRequired = 1;//添加手势到目标view上面[self.blueVIew addGestureRecognizer:tapGesture];//滑动手势,一个手势只能控制一个方向UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(swipeAction:)];//设置滑动方向direction方向// swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;//左// swipeGesture.direction = UISwipeGestureRecognizerDirectionRight;//右// swipeGesture.direction = UISwipeGestureRecognizerDirectionUp;//上swipeGesture.direction = UISwipeGestureRecognizerDirectionDown;//下//手指数swipeGesture.numberOfTouchesRequired = 1;//加到view上[self.yellView addGestureRecognizer:swipeGesture];//拖动手势UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panAction:)];[self.blueVIew addGestureRecognizer:panGesture];//捏合手势UIPinchGestureRecognizer *pinGesture = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(pinAction:)];[self.view addGestureRecognizer:pinGesture];//旋转手势UIRotationGestureRecognizer *rotationGesture = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(rotationAction:)];[self.view addGestureRecognizer:rotationGesture];//长按手势UILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longGesture:)];//设置最短长按时间longGesture.minimumPressDuration = 1;[self.view addGestureRecognizer:longGesture];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIView","date":"2017-03-14T06:47:32.000Z","path":"2017/03/14/UIView/","text":"将一个view加到最上层如果想让一个页面显示在一直显示在最上面就把它加到window上面12345678self.navigationController.navigationBar.backgroundColor = [UIColor blueColor]; self.tabBarController.tabBar.backgroundColor = [UIColor orangeColor]; //获取到window UIWindow *window = [UIApplication sharedApplication].keyWindow; UIView *view = [[UIView alloc] init]; view.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); view.backgroundColor = [UIColor redColor]; [window addSubview:view]; 常用属性方法12345678910111213141516171819202122232425262728293031//获得自己的父控件@property (nonatomic, readonly) UIView *superview;//获得自己的所有子控件对象@property (nonatomic, readonly, copy) NSArray *subviews;//控件的ID标识，父控件可以通过tag来找到对应的子控件@property (nonatomic) NSInteger tag;//控件的形变属性，可以设置平移，比例缩放，角度旋转等属性@property (nonatomic) CGAffineTransform *transform;//添加一个子控件- (void)addSubview:(UIView *)view;//使用这个方法添加的子控件会被塞到subviews数组的最后面//可以使用下面的方法调整子控件在subview数组中的顺序 // 将子控件view插入到subviews数组的index位置 - (void)insertSubview:(UIView *)view atIndex:(NSInteger)index; // 将子控件view显示到子控件siblingSubview的下面 - (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview; // 将子控件view显示到子控件siblingSubview的上面 - (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview; // 将子控件view放到数组的最后面，显示在最上面 - (void)bringSubviewToFront:(UIView *)view; // 将子控件view放到数组的最前面，显示在最下面 - (void)sendSubviewToBack:(UIView *)view;//从父控件中移除- (void)removeFromSuperview;//根据tag值找到控件- (UIView *)viewWithTag:(NSInteger)tag;//控件矩形框在父控件中的位置和尺寸(以父控件的左上角为坐标原点)@property (nonatomic) CGRect fram;//控件矩形框的位置和尺寸(以自己左上角为坐标原点，所以bounds的x、y一般为0)@property (nonatomic) CGRect bounds;//控件中点的位置(以父控件的左上角为坐标原点)@property (nonatomic) CGPoint center;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"本地音乐播放","date":"2017-03-14T06:26:41.000Z","path":"2017/03/14/AVAudioPlayer/","text":"播放本地音乐可以用 AVAudioPlayer12345678910//音频播放类@property (nonatomic, strong) AVAudioPlayer *player;//播放进度@property (weak, nonatomic) IBOutlet UIProgressView *playProgress;//音量滑块@property (weak, nonatomic) IBOutlet UISlider *volumeSlider;NSURL *url = [[NSBundle mainBundle] URLForResource:[NSString stringWithFormat:@&quot;%@.mp3&quot;,self.musicArray[index]] withExtension:nil]; self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil];每个AVAudioPlayer只能播放一个url对应的音乐,他虽然有url属性，但是是只读的，不能修改，只能在初始化时赋值1234567891011121314151617将音乐加载到缓冲区[self.player prepareToPlay];开始播放[self.player play];暂停播放（暂停后可以继续播放）[self.player pause];结束播放（结束后就不能继续播放了）[self.player stop];播放音量@property float volume;获取音乐时长@property(readonly) NSTimeInterval duration;获取当前播放时长@property NSTimeInterval currentTime;显示播放进度//通过音频播放时长的百分比,给progressview进行赋值;self.playProgress.progress = self.player.currentTime/self.player.duration;AVAudioPlayerDelegate12345678//播放结束时执行的动作- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer*)player successfully:(BOOL)flag;//解码错误执行的动作- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer*)player error:(NSError *)error;//处理中断的代码- (void)audioPlayerBeginInteruption:(AVAudioPlayer*)player;//处理中断结束的代码- (void)audioPlayerEndInteruption:(AVAudioPlayer*)player;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS碎片","date":"2017-03-14T05:27:32.000Z","path":"2017/03/14/iOS碎片/","text":"UITabBar123456//去掉(覆盖)原生Tabbar的上横线和背景图[[UITabBar appearance] setShadowImage:[self createImageWithColor:[UIColor clearColor]]];[[UITabBar appearance] setBackgroundImage:[self createImageWithColor:[UIColor clearColor]]];//隐藏tabBar的代码vv.hidesBottomBarWhenPushed = YES; UITabBarButton⾥面显⽰什么内容,由对应子控制器的tabBarItem属性来决定有两种方式可以往UITabBarController中添加子控制器 123[tb addChildViewController:c1];tb.viewControllers=@[c1,c2,c3,c4];展示的顺序和添加的顺序一致 UITabBarItem属性1234@property (nonatomic, copy) NSString *title;//标题文字@property (nonatomic, retain) UIImage *image;//图标@property (nonatomic, retain) UIImage *selectedImage;//选中时的图标@property (nonatomic, retain) NSString *badgeValue;//提醒数字 UIScrollView处理scrollView偏移64像素问题,设置1self.automaticallyAdjustsScrollViewInsets = NO; NSUserDefaults使用NSUserDefaults对数据进行保存之后, 它保存到系统的时间是不确定的，会在将来某一时间点自动将数据保存到Preferences文件夹下面，如果需要即刻将数据存储，可以使用12NSUserDefaults *defaults=[NSUserDefaults standardUserDefaults];[defaults synchronize]; 获取程序根目录12345678910方法一：NSString *home = NSHomeDirectory();方法二：（建议使用如下方法动态获取）NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSUserDomainMask：在用户目录下查找YES：代表用户目录的NSDocumentDirectory：查找Documents文件夹拼接文件路径NSString *path = [doc stringByAppendingPathComponent:@&quot;abc.plist&quot;]; Plist12345678910加载plist数据NSBundle的作用：用来访问与之对应的资源包内部的文件，可以用来获得文件的全路径,一个NSBundle对象对应一个资源包（图片、音频、视频、plis等文件）项目中添加的资源都会被添加到主资源包中, [NSBundle mainBundle]关联的就是项目的主资源包 NSBundle *bundle = [NSBundle mainBundle]; // 利用mainBundle获得plist文件在主资源包中的全路径 NSString *file = [bundle pathForResource:@&quot;shops&quot; ofType:@&quot;plist&quot;]; 写入plist [_dataArray writeToFile:file atomically:YES]; 去除NavigationBar下面的线 1self.navigationController.navigationBar.barStyle = UIBaselineAdjustmentNone; 重写方法121.重写对象的-(void)description;方法，可以自定义NSLog输出。2.重写-(void)dealloc;方法，自定义销毁（要保证super dealloc是重写方法里的最后一句） NSArray121.componentsSeparatedByString:以给定的字符串将目标字符串切分成数组2.componentsJoinedByString:以给定字符串将数组合成一个字符串 NSString1234567891011121314151617181.isEqualToString:比较两个字符串的内容是否相同2.compare:将接收对象和传递过来的字符串逐一比较3.compare:options:不区分大小写的比较（NSCaseInsensitiveSearch:不区分大小写 NSLiteralSearch:进行完全比较，区分大小写NSNumericSearch:比较字符串字符个数）4.-(BOOL)hasPrefix:(NSString)aString:检查字符串是否以另一个字符串开头5.-(BOOL)hasSuffix:(NSString)aString: 检查字符串是否以另一个字符串结尾6.-(NSRange)rangeOfString:(NSString)aString:检查字符串里是否包含其他字符串7.-(void)appendString:(NSString)aString:添加字符串8.-(void)appendFormat:(NSString)format,…:添加字符串9.-(void)deleteCharactersInRange:(NSRange)aRange:从字符串中删去一段10.initWithContentsOfFile:encoding:error:打开指定路径上的文本，读取文件内容，并使用文件内容初始化一个字符串例：NSError *error =nil;NSString *string = [[NSString alloc] initWithContentsOfFile:@&quot;/tmp/wprds.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error];if(nil != error)&#123; NSLog(@&quot;%@&quot;,[error localizedDescription]);&#125; ** Staticstatic的作用：1.修饰局部变量让局部变量只初始化一次局部变量在程序中只有一份内存并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）2.修饰全局变量全局变量的作用域仅限于当前文件","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Xcode工程配置","date":"2017-03-14T02:39:35.000Z","path":"2017/03/14/Xcode工程配置/","text":"查找Xcode里的iOS版本包路径1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 权限获取1234567891011添加一个属性，输入Privacy后就会出现自动提示:描述字符串自己随意填写就可以,但是一定要填写，不然会引发包无效的问题，导致上传打包后构建版本一直不显示。麦克风权限 - Microphone Usage Description - 是否允许此App使用你的麦克风？相机权限 - Camera Usage Description - 是否允许此App使用你的相机？相册权限 - Photo Library Usage Description - 是否允许此App访问你的媒体资料库？通讯录权限 - Contacts Usage Description - 是否允许此App访问你的通讯录？蓝牙权限 - Bluetooth Peripheral Usage Description - 是否许允此App使用蓝牙？语音转文字权限 - Speech Recognition Usage Description - 是否允许此App使用语音识别？日历权限 - Calendars Usage Description - 是否允许此App使用日历？定位权限 - Location When In Use Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据定位权限 - Location Always Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"单例","date":"2017-03-14T02:30:14.000Z","path":"2017/03/14/单例/","text":"GCD方式123456789101112131415//ViewController类的单例（调用单例时直接调这个方法）+ (instancetype)sharedInstance&#123; static ViewController *singleton = nil; //是否存在的判断 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil] instantiateViewControllerWithIdentifier:@&quot;musicVC&quot;]; 或 singleton = [[ViewController alloc] init]; //自定义处理 &#125;); return singleton;&#125; 经典方式重写allocWithZone方法XXX.m1234567891011121314id _XXX(类名);//alloc方法的底层方法+(id)allocWithZone:(struct _NSZone *)zone&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [super allocWithZone:zone]; //其他自定义处理 &#125; &#125; &#125;&#125; XXX.h1+(instancetype)sharedXXX; XXX.m1234567891011+(instancetype)sharedXXX&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [[self alloc] init]; &#125; &#125; &#125; return _XXX;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIDynamic物理引擎","date":"2017-03-14T01:43:46.000Z","path":"2017/03/14/UIDynamic物理引擎/","text":"UIDynamic隶属于UIKit框架可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象(重力、弹性碰撞等现象)UIDynamic使用步骤：1.创建一个物理仿真器（顺便设置仿真范围）1UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];//ReferenceView:仿真范围2.创建相应的物理仿真行为（顺便添加物理仿真元素）123456//重力行为UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];//Items:要进行行为的对象//碰撞检测行为UICollisionBehavior *collision = [[UICollisionBehavior alloc] initWithItems:@[self.blueView]];//将参照视图的边框转变为碰撞检测的边界collision.translatesReferenceBoundsIntoBoundary = YES；3.将物理仿真行为添加到物理仿真器中，开始仿真1[animator addBehavior:grvity]; UIDynamic提供了以下几种物理仿真行为:UIGravityBehavior — 重力行为UICollisionBehavior — 碰撞行为:为Item与边界以及Item之间添加碰撞效果。UISnapBehavior — 捕捉行为UIPushBehavior — 推动行为UIAttachmentBehavior — 附着行为UIDynamicItemBehavior — 动力元素行为:配置一些公用的属性，与其他的Dynamic Behavior共同配合 常用属性方法12345678910111213141516//属性@property (nonatomic, readonly) UIView* referenceView;//参照视图@property (nonatomic, readonly, copy) NSArray* behaviors;//添加到物理仿真器中的所有物理仿真行为@property (nonatomic, readonly, getter = isRunning) BOOL running;//判定animator中是否还有行为正在执行@property (nonatomic, assign) id &lt;UIDynamicAnimatorDelegate&gt; delegate;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）//方法- (void)addBehavior:(UIDynamicBehavior *)behavior;//添加指定的行为动画- (void)removeBehavior:(UIDynamicBehavior *)behavior;//移除指定的行为动画- (void)removeAllBehaviors;//移除所有的行为- (NSTimeInterval)elapsedTime;//行为执行的时间，需要注意的是如果我们对同一个行为进行添加和移除操作时，时间会累积。- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;//如果想要改变center或者transform必须调用这个方法 ,否则改变是无效的. //代理方法- (void)dynamicAnimatorWillResume:(UIDynamicAnimator *)animator;//add行为时调用- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator;//remove行为时调用","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"隐藏文件","date":"2017-03-10T09:28:44.000Z","path":"2017/03/10/隐藏文件/","text":"在Windows系统下 隐藏rar到jpg图片中去：1.把要隐藏的文件生成压缩包2.新建一个文本文件，写入代码：12copy /b 图片名.jpg+压缩包名.rar 生成的图片名.jpg 3.将文本文件后缀改为bat4.运行bat文件 取出隐藏的文件：将jpg改为rar，然后解压 12copy /b 1+2 3该代码是将1，2两个文件进行连接（可以合并mp3,txt,,,,多种格式）,合并完1是显示的格式","tags":[{"name":"其他","slug":"其他","permalink":"https://Misaka-NO10032.github.io/tags/其他/"}]},{"title":"UIScrollView","date":"2017-03-10T08:01:52.000Z","path":"2017/03/10/UIScrollView/","text":"属性1234567891011121314151617181920212223@property(nonatomic) CGPoint contentOffset; 表示UIScrollView当前显示的位置（其实就是内容左上角与scrollView左上角的间距值）@property(nonatomic) CGSize contentSize; 表示UIScrollView内容的尺寸@property(nonatomic) UIEdgeInsets contentInset; 这个属性能够在UIScrollView的4周增加额外的滚动区域，一般用来避免scrollView的内容被其他控件挡住@property(nonatomic) BOOL bounces;设置UIScrollView是否需要弹簧效果@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置UIScrollView是否能滚动@property(nonatomic) BOOL showsHorizontalScrollIndicator;是否显示水平滚动条@property(nonatomic) BOOL showsVerticalScrollIndicator;是否显示垂直滚动条@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled;是否设置分页显示 UIScrollViewDelegate滚动1234567891011121314滚动开始- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;滚动中。。。- (void)scrollViewDidScroll:(UIScrollView *)scrollView;滚动结束- (void)scrollViewDidEndDragging:(UIscrollView *)scrollView willDecelerate:(BOOL)decelerate;开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;减速停止- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;是否支持滑动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;滑动到顶部时调用该方法- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 缩放123456789101112缩放实现步骤:1. 设置UIScrollView的id&lt;UISCrollViewDelegate&gt; delegate代理对象2. 设置minimumZoomScale ：缩小的最小比例3. 设置maximumZoomScale ：放大的最大比例4. 让代理对象实现下面的方法，返回需要缩放的视图控件 - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;跟缩放相关的其他代理方法缩放开始的时候调用 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view正在缩放的时候调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView UIPageControl12345678910一共有多少页@property(nonatomic) NSInteger numberOfPages;当前显示的页码@property(nonatomic) NSInteger currentPage; 只有一页时，是否需要隐藏页码指示器@property(nonatomic) BOOL hidesForSinglePage;其他页码指示器的颜色@property(nonatomic,retain) UIColor *pageIndicatorTintColor;当前页码指示器的颜色@property(nonatomic,retain) UIColor *currentPageIndicatorTintColor;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIButton","date":"2017-03-10T07:09:01.000Z","path":"2017/03/10/UIButton/","text":"12345678获得按钮的文字- (NSString *)titleForState:(UIControlState)state; 获得按钮的文字颜色- (UIColor *)titleColorForState:(UIControlState)state;获得按钮内部的小图片- (UIImage *)imageForState:(UIControlState)state;获得按钮的背景图片- (UIImage *)backgroundImageForState:(UIControlState)state;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UITableView","date":"2017-03-10T06:56:37.000Z","path":"2017/03/10/UITableView/","text":"去掉多余的分割线1self.tableView.tableFooterView = [[UIView alloc] init]; 刷新12345678刷新全部数据[self.tableView reloadData];刷新索引[self.tableView reloadSectionIndexTitles];刷新某个Section[self.tableView reloadSections:(nonnull NSIndexSet *) withRowAnimation:(UITableViewRowAnimation)];刷新某行[self.tableView reloadRowsAtIndexPaths:(nonnull NSArray&lt;NSIndexPath *&gt; *) withRowAnimation:(UITableViewRowAnimation)];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIResponder相关","date":"2017-03-10T02:48:15.000Z","path":"2017/03/10/UIResponder/","text":"UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events,如插入耳机调节音量触发的事件)。UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder,所以这些类都可以响应事件。1234567891011121314//下一个接收事件的响应者@property(nonatomic, readonly, nullable) UIResponder *nextResponder;- (nullable UIResponder*)nextResponder;//是否成为第一响应者@property(nonatomic, readonly) BOOL canBecomeFirstResponder;//default is NO- (BOOL)canBecomeFirstResponder;//default is NO- (BOOL)becomeFirstResponder;//是否能取消第一响应者@property(nonatomic, readonly) BOOL canResignFirstResponder;//default is YES- (BOOL)canResignFirstResponder;//default is YES- (BOOL)resignFirstResponder;//是否是第一响应者@property(nonatomic, readonly) BOOL isFirstResponder;- (BOOL)isFirstResponder; 触摸事件(Touch Events)12345678910//触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; //触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸中断- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//3D触摸- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1); 运动事件(Motion Events)123456//运动开始- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动中断- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0); 远程控制事件(Remote Control Events）12//远程控制- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0); UITouch当用户用手指触摸屏幕时，系统会为每根手指创建一个与之关联的UITouch对象UITouch保存着跟手指相关的信息，比如触摸的位置、时间、阶段；当手指移动时，系统会更新与之相对应的UITouch对象，使之能够一直保存该手指即时的触摸位置1234- (CGPoint)locationInView:(UIView *)view;函数返回触摸点相对view这个视图的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置- (CGPoint)previousLocationInView:(UIView *)view;该方法返回了前一个触摸点相对view的值 UITouch属性12345678910//触摸所在的窗口@property (nonatomic, readonly, retain) UIWindow *window;//触摸所在的view@property (nonatomic, readonly, retain) UIView *view;//短时间内点击屏幕的次数，可根据tapCount判断单击、双击或更多点击@property (nonatomic, readonly,) NSUInteger tapCount;//记录了触摸事件产生或变化时的时间，单位 （秒）@property (nonatomic, readonly) NSTimeInterval timestamp;//当前触摸事件所处的状态@property (nonatomic, readonly) UITouchPhase phase; UIEventUIEvent：称为事件对象，记录事件产生的时刻和类型.每产生一个事件，就会产生一个UIEvent对象常见属性12345//事件类型@property(nonatomic, readonly) UIEventType type;@property(nonatomic, readonly) UIEventSubtype subtype;//事件产生的时间@property(nonatomic, readonly) NSTimeInterval timestamp; UIEvent还提供相应的方法可以获得在某个view上面的触摸对象（UITouch）12- (NSSet *)allTouches；//获得全部UITouch- (NSSet *)touchesForView:(UIView *)view;//获取view上的UITouch","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]}]