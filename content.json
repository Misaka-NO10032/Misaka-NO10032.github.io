[{"title":"Python定义类","date":"2017-06-12T06:19:05.000Z","path":"2017/06/12/Python定义类/","text":"定义类在Python中，类通过 class 关键字定义。以 Person 为例，定义一个Person类如下：1234class Person(object): pass #pass是空语句，是为了保持程序结构的完整性.pass 不做任何事情，一般用做占位语句。按照 Python 的编程习惯，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。 创建实例1person = Person() 由于Python是动态语言，对每一个实例，都可以直接给他们添加属性并赋值123456789101112131415161718class Super(object): passsubclassA = Super()subclassA.name = &quot;name&quot;print subclassAprint subclassA.name&gt;&gt;&lt;__main__.Super object at 0x10c022650&gt;namesubclassB = Super()subclassB.age = 17print subclassBprint subclassB.age&gt;&gt;&lt;__main__.Super object at 0x10c022890&gt;17 初始化实例属性123456789101112131415161718192021在定义 Person 类时，可以为Person类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用，我们就能在此为每个实例都统一加上以下属性：class Person(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birth__init__() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。相应地，创建实例时，就必须要提供除 self 以外的参数：xiaoming = Person(&apos;Xiao Ming&apos;, &apos;Male&apos;, &apos;1991-1-1&apos;)xiaohong = Person(&apos;Xiao Hong&apos;, &apos;Female&apos;, &apos;1992-2-2&apos;)有了__init__()方法，每个Person实例在创建时，都会有 name、gender 和 birth 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符：print xiaoming.name# 输出 &apos;Xiao Ming&apos;print xiaohong.birth# 输出 &apos;1992-2-2&apos; python中访问限制123456789101112131415161718Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问。class Person(object): def __init__(self, name): self.name = name self._title = &apos;Mr&apos; self.__job = &apos;Student&apos;p = Person(&apos;Bob&apos;)print p.name# =&gt; Bobprint p._title# =&gt; Mrprint p.__job# =&gt; ErrorTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Person&apos; object has no attribute &apos;__job&apos;但是，如果一个属性以&quot;__xxx__&quot;的形式定义，那它又可以被外部访问了，以&quot;__xxx__&quot;定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常我们不要把普通属性用&quot;__xxx__&quot;定义。 创建类属性类是模板，而实例则是根据类创建的对象。绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份。123456789101112131415161718192021222324class Person(object): count = 0 def __init__(self,name): Person.count += 1 self.name = namep1 = Person(&apos;Bob&apos;)print Person.count&gt;&gt;1p2 = Person(&apos;Alice&apos;)print Person.count&gt;&gt;2p3 = Person(&apos;Tim&apos;)print Person.count&gt;&gt;3print Person.count #因为类属性是直接绑定在类上的，所以，访问类属性不需要创建实例，就可以直接访问&gt;&gt;3 当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。 定义实例方法12345678910111213141516class Person(object): def __init__(self, name, score): self.__score = score def get_grade(self): if self.__score &gt;= 80: return &apos;A&apos; elif self.__score &gt;= 60: return &apos;B&apos; else: return &apos;C&apos;p1 = Person(&apos;Bob&apos;, 90)print p1.get_grade()&gt;&gt;A 我们在 class 中定义的实例方法其实也是属性，它实际上是一个函数对象把函数添加为属性1types.MethodType(f, p, Class) #参数(函数，实例，类) 定义类方法和属性类似，方法也分实例方法和类方法。1234567891011121314151617通过标记一个 @classmethod，该方法将绑定到 Person 类上class Person(object): __count = 0 @classmethod def how_many(cls): return cls.__count def __init__(self,name): self.name = name Person.__count += 1print Person.how_many()&gt;&gt;0p1 = Person(&apos;Bob&apos;)print Person.how_many()&gt;&gt;1 注意：因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。 继承12345678class Person(object): #父类 def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): #子类 def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) #初始化父类 self.score = score #初始化子类属性 多继承12345678910111213141516171819class A(object): def __init__(self, a): print &apos;init A...&apos; self.a = aclass B(A): def __init__(self, a): super(B, self).__init__(a) print &apos;init B...&apos;class C(A): def __init__(self, a): super(C, self).__init__(a) print &apos;init C...&apos;class D(B, C): def __init__(self, a): super(D, self).__init__(a) print &apos;init D...&apos; 判断类型函数isinstance()可以判断一个变量的类型，既可以用在Python内置的数据类型如str、list、dict，也可以用在我们自定义的类，它们本质上都是数据类型。1234567891011121314151617181920212223242526272829303132class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = scoreclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = courset = Teacher(&apos;Alice&apos;, &apos;Female&apos;, &apos;English&apos;)print isinstance(t,Person)&gt;&gt;Trueprint isinstance(t,Student)&gt;&gt;Falseprint isinstance(t,Teacher)&gt;&gt;Trueprint isinstance(t,object)&gt;&gt;True 多态123456789101112131415161718192021222324252627282930313233343536class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def whoAmI(self): return &apos;I am a Person, my name is %s&apos; % self.nameclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return &apos;I am a Student, my name is %s&apos; % self.nameclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = course def whoAmI(self): return &apos;I am a Teacher, my name is %s&apos; % self.namedef who_am_i(x): print x.whoAmI()p = Person(&apos;Tim&apos;, &apos;Male&apos;)s = Student(&apos;Bob&apos;, &apos;Male&apos;, 88)t = Teacher(&apos;Alice&apos;, &apos;Female&apos;, &apos;English&apos;)who_am_i(p)who_am_i(s)who_am_i(t)运行结果：I am a Person, my name is TimI am a Student, my name is BobI am a Teacher, my name is Alice 获取对象信息1234567891011121314151617181920212223242526例如，已有定义：class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return &apos;I am a Student, my name is %s&apos; % self.name首先可以用 type() 函数获取变量的类型，它返回一个 Type 对象：&gt;&gt;&gt;print type(123)&lt;type &apos;int&apos;&gt;&gt;&gt;&gt; s = Student(&apos;Bob&apos;, &apos;Male&apos;, 88)&gt;&gt;&gt;print type(s)&lt;class &apos;__main__.Student&apos;&gt;其次，可以用 dir() 函数获取变量的所有属性：&gt;&gt;&gt;print dir(123) # 整数也有很多属性...[&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__and__&apos;, &apos;__class__&apos;, &apos;__cmp__&apos;, ...]&gt;&gt;&gt;print dir(s)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;gender&apos;, &apos;name&apos;, &apos;score&apos;, &apos;whoAmI&apos;]&gt;&gt;&gt; print filter(lambda x:x[0:2] != &apos;__&apos;,dir(s))[&apos;gender&apos;, &apos;name&apos;, &apos;score&apos;, &apos;whoAmI&apos;] 特殊方法特殊方法是定义在类中的，不需要手动调用，python的某些函数和操作符会自动去调用对应的特殊方法。我们只需要编写需要的特殊方法，但是有关联性的特殊方法要同时实现1.要把一个类的实例变成 str1234567891011121314 Python 定义了__str__()和__repr__()两种方法，__str__()用于显示给用户，而__repr__()用于显示给开发人员。class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __str__(self): return &apos;(Person: %s, %s)&apos; % (self.name, self.gender) __repr__ = __str__ #偷懒的定义__repr__的方法&gt;&gt;&gt; p = Person(&apos;Bob&apos;, &apos;male&apos;)&gt;&gt;&gt; print p(Person: Bob, male)&gt;&gt;&gt; p&lt;main.Person object at 0x10c941890&gt; 2.排序(对类进行自定义排序规则)123456789101112131415161718class Student(object): def __init__(self, name, score): self.name = name self.score = score def __str__(self): return &apos;(%s: %s)&apos; % (self.name, self.score) __repr__ = __str__ def __cmp__(self, s): if self.name &lt; s.name: return -1 elif self.name &gt; s.name: return 1 else: return 0L = [Student(&apos;Tim&apos;, 99), Student(&apos;Bob&apos;, 88), Student(&apos;Alice&apos;, 77)]print sorted(L)&gt;&gt;[(Alice: 77), (Bob: 88), (Tim: 99)] 3.长度123456789class Students(object): def __init__(self, *args): self.names = args def __len__(self): return len(self.names)ss = Students(&apos;Bob&apos;, &apos;Alice&apos;, &apos;Tim&apos;)print len(ss)&gt;&gt;3 4.数学运算1234567891011121314151617181920212223242526272829303132333435363738394041424344class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __add__(self, r): #加 return Rational(self.p * r.q + self.q * r.p, self.q * r.q) def __sub__(self, r): #减 return Rational(self.p*r.q-self.q*r.p,self.q*r.q) def __mul__(self, r): #乘 return Rational(self.p*r.p,self.q*r.q) def __div__(self, r): #除 return Rational(self.p*r.q,self.q*r.p) def __str__(self): if self.p &lt; self.q: k = self.p else: k = self.q for x in range(1,k+1): if self.p%x==0 and self.q%x == 0: self.p = self.p / x self.q = self.q / x return &apos;%s/%s&apos; % (self.p, self.q) __repr__ = __str__ __repr__ = __str__r1 = Rational(1, 2)r2 = Rational(1, 4)print r1 + r2print r1 - r2print r1 * r2print r1 / r2&gt;&gt;3/41/41/82/1 5.数据类型转换12345678910111213class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __int__(self): return self.p // self.q def __float__(self): return float(self.p) / self.qprint float(Rational(7, 2))print float(Rational(1, 3)) 6.property1234567891011121314151617181920212223242526272829303132333435363738如果没有定义set方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。给Student类加一个grade属性，根据 score 计算 A（&gt;=80）、B、C（&lt;60）。class Student(object): def __init__(self, name, score): self.name = name self.__score = score @property def score(self): return self.__score @score.setter def score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError(&apos;invalid score&apos;) self.__score = score @property def grade(self): if self.__score &gt;= 80: return &apos;A&apos; elif self.__score &gt;= 60: return &apos;B&apos; else: return &apos;C&apos;s = Student(&apos;Bob&apos;, 59)print s.grades.score = 60print s.grades.score = 99print s.grade&gt;&gt;CBA 7.限制属性的添加1234567__slots__是指一个类允许的属性列表,__slots__的目的是限制当前类所能拥有的属性，如果不需要添加任意动态的属性，使用__slots__也能节省内存。class Student(object): __slots__ = (&apos;name&apos;, &apos;gender&apos;, &apos;score&apos;) def __init__(self, name, gender, score): self.name = name self.gender = gender self.score = score 8。类实例变为可调用对象123456789101112一个类实例要变成一个可调用对象，只需要实现一个特殊方法__call__()。class Fib(object): #斐波那契数列 def __call__(self,num): a,b,L=0,1,[] for n in range(num): L.append(a) a,b=b,a+b return L f = Fib()print f(10)&gt;&gt;[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)进阶二","date":"2017-06-12T05:42:19.000Z","path":"2017/06/12/Python进阶二/","text":"模块导入要使用一个模块，我们必须首先导入该模块。Python使用import语句导入一个模块。12345678例如，导入系统自带的模块 math：import math你可以认为math就是一个指向已导入模块的变量，通过该变量，我们可以访问math模块中所定义的所有公开的函数、变量和类：&gt;&gt;&gt; math.pow(2, 0.5) # pow是函数1.4142135623730951&gt;&gt;&gt; math.pi # pi是变量3.141592653589793 如果我们只希望导入用到的math模块的某几个函数，而不是所有函数，可以用下面的语句：123456from math import pow, sin, log这样，可以直接引用 pow, sin, log 这3个函数，但math的其他函数没有导入进来：&gt;&gt;&gt; pow(2, 10)1024.0&gt;&gt;&gt; sin(3.14)0.0015926529164868282 如果遇到名字冲突怎么办？比如math模块有一个log函数，logging模块也有一个log函数，如果同时使用，如何解决名字冲突？123456789101112如果使用import导入模块名，由于必须通过模块名引用函数名，因此不存在冲突：import math, loggingprint math.log(10) # 调用的是math的log函数logging.log(10, &apos;something&apos;) # 调用的是logging的log函数如果使用 from...import 导入 log 函数，势必引起冲突。这时，可以给函数起个“别名”来避免冲突：from math import logfrom logging import log as logger # logging的log现在变成了loggerprint log(10) # 调用的是math的loglogger(10, &apos;import from logging&apos;) # 调用的是logging的log 动态导入模块如果导入的模块不存在，Python解释器会报 ImportError 错误：有的时候，两个不同的模块提供了相同的功能，比如 StringIO 和 cStringIO 都提供了StringIO这个功能。这是因为Python是动态语言，解释执行，因此Python代码运行速度慢。如果要提高Python代码的运行速度，最简单的方法是把某些关键函数用 C 语言重写，这样就能大大提高执行速度。同样的功能，StringIO 是纯Python代码编写的，而 cStringIO 部分函数是 C 写的，因此 cStringIO 运行速度更快。利用ImportError错误，我们经常在Python中动态导入模块：1234567try: from cStringIO import StringIOexcept ImportError: from StringIO import StringIO上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。try 的作用是捕获错误，并在捕获到指定错误时执行 except 语句。 利用import … as …，还可以动态导入不同名称的模块。 添加第三方模块pip install12pip install web.py #添加web模块查找第三方模块：https://pypi.python.org/ 12345678910111213141516__future__Python的新版本会引入新的功能，但是，实际上这些功能在上一个老版本中就已经存在了。要“试用”某一新的特性，就可以通过导入__future__模块的某些功能来实现。例如，Python 2.7的整数除法运算结果仍是整数：&gt;&gt;&gt; 10 / 33但是，Python 3.x已经改进了整数的除法运算，“/”除将得到浮点数，“//”除才仍是整数：&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33要在Python 2.7中引入3.x的除法规则，导入__future__的division：&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; print 10 / 33.3333333333333335","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)进阶","date":"2017-06-07T08:29:14.000Z","path":"2017/06/07/Python进阶/","text":"python函数可以把函数作为参数12345&gt;&gt;&gt; def add(x, y, f):... return f(x)+f(y)...&gt;&gt;&gt; add(-5, 9, abs)14 函数返回值可以为函数12345678&gt;&gt;&gt; def f():... def g(x):... return x*x... return g...&gt;&gt;&gt; fn = f()&gt;&gt;&gt; print fn(3)9 闭包内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。123456789101112131415161718192021222324252627&gt;&gt;&gt; # 希望一次返回3个函数，分别计算1x1,2x2,3x3:... def count():... fs = []... for i in range(1, 4):... def f(i):... return i*i... fs.append(f)... return fs...&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; print f1(),f2(),f3()9 9 9&gt;&gt;&gt; # 希望一次返回3个函数，分别计算1x1,2x2,3x3:... def count():... fs = []... for i in range(1, 4):... def f(n = i):... return n*n... fs.append(f)... return fs...&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; print f1(),f2(),f3()1 4 9对比上面两个函数可知：python函数定义时仅走声明部分，只有当真正调用函数时才会走函数的实现部分 匿名函数关键字lambda 表示匿名函数，冒号前面的表示函数参数，后面表达式为结果。匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码12345&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81]可以看出，匿名函数 lambda x: x * x 实际上就是：def f(x): return x * x 装饰器(decorator)Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。12345678910111213141516171819202122232425262728293031323334353637383940无参decoratordef fn(f): def s(x): r = f(x) print &apos;!&apos; return r return s@fndef g(x): return xprint g(5)&gt;&gt;!5有参无参有参无参decoratorimport timedef performance(unit): def returnfunction(f): def decoratorfuntion(*args,**kw): t1 = time.time() # *args,**kw可传入任意数量参数 r = f(*args,**kw) t2 = time.time() t = t2-t1 if unit == &apos;ms&apos;: t = t*1000 print &apos;call %s() in %f%s&apos;%(f.__name__,t,unit) return r return decoratorfuntion return returnfunction@performance(&apos;ms&apos;)def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10)&gt;&gt;call factorial() in 14.061928ms3628800 12345678910111213141516171819202122232425262728293031323334353637383940414243444546完善decorator有decorator的情况下，打印函数名：def log(f): def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) return wrapper@logdef f2(x): passprint f2.__name__&gt;&gt;wrapper可见，由于decorator返回的新函数函数名已经不是&apos;f2&apos;，而是@log内部定义的&apos;wrapper&apos;。这对于那些依赖函数名的代码就会失效.这对于那些依赖函数名的代码就会失效。decorator还改变了函数的__doc__等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：def log(f): def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) wrapper.__name__ = f.__name__ wrapper.__doc__ = f.__doc__ return wrapper这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的functools可以用来自动化完成这个“复制”的任务：import functoolsdef log(f): @functools.wraps(f) def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) return wrapper最后需要指出，由于我们把原函数签名改成了(*args, **kw)，因此，无法获得原函数的原始参数信息。即便我们采用固定参数来装饰只有一个参数的函数：def log(f): @functools.wraps(f) def wrapper(x): print &apos;call...&apos; return f(x) return wrapper也可能改变原函数的参数名，因为新函数的参数名始终是 &apos;x&apos;，原函数定义的参数名不一定叫 &apos;x&apos;。@functools.wraps(f)加在def wrapper(*args, **kw):前面 Python内置高阶函数1.map():接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。123456假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：&gt;&gt;&gt; def format_name(s):... return s[0].upper()+s[1:].lower()...&gt;&gt;&gt; print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 2.reduce():接收一个函数 f (f 必须接收两个参数)，一个list,还可以接收第3个可选参数，作为计算的初始值。reduce()对list的每个元素反复调用函数f，并返回最终结果值。1234567&gt;&gt;&gt; def f(x,y):... return x*y...&gt;&gt;&gt; print reduce(f,[1,2,3])6&gt;&gt;&gt; print reduce(f,[1,2,3],2)12 3.filter():接收一个函数 f 和一个list,这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。123456例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：&gt;&gt;&gt; def f(x):... return x%2 == 1...&gt;&gt;&gt; filter(f,[1,2,3,4,5,6,7,8])[1, 3, 5, 7] 4.sorted():接收一个list和一个函数 f ,以f的排序规则返回一个重新排序的list，默认f为从小到大排序。比较函数f的定义是，传入两个待比较的元素 x, y.如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。123456789101112&gt;&gt;&gt; def f(x,y):... if x &gt; y:... return -1... elif x &lt; y:... return 1... else:... return 0...&gt;&gt;&gt; sorted([1,5,3,8,10],f)[10, 8, 5, 3, 1]&gt;&gt;&gt; sorted([1,5,3,8,10])[1, 3, 5, 8, 10]5.functools.partial偏函数可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。偏函数第一个参数为函数f，后面的参数为f的参数的赋值表达式。注意：使用偏函数必须保证偏函数至少有一个必须赋值的参数123456789101112import functoolsdef f(x,y,z): return x,y,zg = functools.partial(f,y = 1,z = 1)print f(1,2,3)&gt;&gt;(1, 2, 3)print g(1)&gt;&gt;(1, 1, 1)","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)基础二","date":"2017-06-07T04:05:23.000Z","path":"2017/06/07/Python基础二/","text":"迭代Python中，迭代永远是取出元素本身，而非元素的索引。1.对于有序集合，元素确实是有索引的。我们使用 enumerate() 函数可以取到索引；1234567891011121314151617181920212223&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul实际上，enumerate() 函数把：[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]变成了类似：[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)]因此，迭代的每一个元素实际上是一个tuple：for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：for index, name in enumerate(L): print index, &apos;-&apos;, name这样不但代码更简单，而且还少了两条赋值语句。可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 2.迭代dict的value123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.values()[85, 95, 59] 3.迭代dict的key和value1234567&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 生成list12345678请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100] print [x*(x+1) for x in range(1,101,2)] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]多层表达式利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。print [x*100+y*10+z for x in range(1,10) for y in range(0,10) for z in range(1,10) if x == z]","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)基础","date":"2017-06-07T01:03:35.000Z","path":"2017/06/07/python基础/","text":"Python注意事项：1.Python区分大小写，2.Python代码有缩进规则.具有相同缩进的代码被视为代码块.Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。3.注释用”#”4.变量名：大小写英文，数字，下划线，数字不能开头 Python数据类型1.布尔值：Ture、False2.逻辑运算符：and(与)、or(或)、not(非)3.空：None4.list12345678list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据L = [0,&apos;aaaa&apos;,True]索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。因此，要打印第一个，用 L[0]:&gt;&gt;&gt; print L[0]我们可以用 -1 这个索引来表示最后一个元素，类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示&gt;&gt;&gt; print L[-1] 123456添加新元素第一个办法是用 list 的 append() 方法，把新元素追加到 list 的末尾另一个方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素删除元素如果元素排在最后一个，我们可以用list的pop()方法删除，若不是最后一个，可在（）内传入索引值来删除Python中替换元素,通过索引值直接赋值替换 5.tuple12345tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。t = (0,&apos;aaaa&apos;,False)因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义t = (1,)tuple是不可变的，但是，如果tuple里面有list元素，那么list元素可以改变。所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向&apos;a&apos;，就不能改成指向&apos;b&apos;，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 1234567891011121314151617对list和tuple进行切片L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：&gt;&gt;&gt; L[:3]只用一个 : ，表示从头到尾：&gt;&gt;&gt; L[:]因此，L[:]实际上复制出了一个新list或tuple切片操作还可以指定第三个参数：&gt;&gt;&gt; L[::2]第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片L[-2:]L[:-2]L[-4:-1:2]字符串 &apos;xxx&apos;和 Unicode字符串 u&apos;xxx&apos;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 6.dict1234567891011121314151617181920用 dict 表示“名字”-“成绩”的查找表如下：d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。花括号 &#123;&#125; 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。访问dict，可以简单地使用 d[key] 的形式来查找对应的 value注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。要避免 KeyError 发生，有两个办法：一是先判断一下 key 是否存在，用 in 操作符：if &apos;Paul&apos; in d: print d[&apos;Paul&apos;]如果 &apos;Paul&apos; 不存在，if语句判断为False，自然不会执行 print d[&apos;Paul&apos;] ，从而避免了错误。二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None dict中作为key的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。12345更新dict用赋值语句：&gt;&gt;&gt; d[&apos;Paul&apos;] = 72如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value遍历dict，直接使用for循环可以遍历 dict 的 key：由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 7.setset内部存储的元素是无序的,set会自动去掉重复的元素12345678910创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])访问 set中的某个元素实际上就是判断一个元素是否在set中。我们可以用 in 操作符判断：Bart是该班的同学吗？&gt;&gt;&gt; &apos;Bart&apos; in sTrueBill是该班的同学吗？&gt;&gt;&gt; &apos;Bill&apos; in sFalse set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。12345由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。直接使用 for 循环可以遍历 set 的元素：添加元素时，用set的add()方法：如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了删除set中的元素时，用set的remove()方法：如果删除的元素不存在set中，remove()会报错如果删除的元素不存在set中，remove()会报错 if、for、while循环过程中，可以用break退出当前循环，还可以用continue跳过本次循环后续代码，继续下一次循环。1234567891011&gt;&gt;&gt; a = 5&gt;&gt;&gt; if a &gt;= 3:... print &apos;yes&apos;... print a... elif a &gt;= 6:... print &apos;&gt;=6&apos;... else:... print &apos;&lt;3&apos;...yes5 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y 12345N = 10x = 0while x &lt; N: print x x = x + 1 函数在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。12345678910111213def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s,n函数可以有默认参数，可以返回多个值在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：def fn(*args): print args可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 printprint可以通过”,”或”+”一次输出多个值，区别在于：“,”作间隔输出时不同值之间会有一个空格出现，可以输出不同的数据类型“+”作间隔输出时不同值会连在一起，只能输出同数据类型12345678910111213&gt;&gt;&gt; print &quot;python&quot;,&quot;print&quot;python print&gt;&gt;&gt; print &quot;python&quot;+&quot;print&quot;pythonprint&gt;&gt;&gt; print &quot;python&quot;,3python 3&gt;&gt;&gt; print &quot;python&quot;+3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot concatenate &apos;str&apos; and &apos;int&apos; objects r’…’和r’’’…’’’如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。r’…’输出单行字符串,如果要表示多行字符串，可以用’’’…’’’表示12345678910&gt;&gt;&gt; print &quot;\\\\\\\\&quot;\\\\&gt;&gt;&gt; print r&quot;\\\\\\\\&quot;\\\\\\\\&gt;&gt;&gt; print r&apos;&apos;&apos;\\\\\\\\... qqqqq... aaaa&apos;&apos;&apos;\\\\\\\\qqqqqaaaa 早期python不支持中文字符串编码，可以用u’…’和u’’’…’’’输出单行和多行 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释1# -*- coding: utf-8 -*-","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"多线程","date":"2017-05-17T06:34:41.000Z","path":"2017/05/17/多线程/","text":"NSThread一个NSThread对象就代表一条线程123456789101112131415NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start];// 线程一启动，就会在线程thread中执行self的run方法主线程相关用法+ (NSThread *)mainThread; // 获得主线程- (BOOL)isMainThread; // 是否为主线程+ (BOOL)isMainThread; // 是否为主线程获得当前线程NSThread *current = [NSThread currentThread];线程的名字- (void)setName:(NSString *)n;- (NSString *)name; 其他创建线程方式1234567创建线程后自动启动线程[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];隐式创建并启动线程[self performSelectorInBackground:@selector(run) withObject:nil];上述2种创建线程方式的优缺点优点：简单快捷缺点：无法对线程进行更详细的设置 控制线程状态1234567891011121314启动线程- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态阻塞（暂停）线程+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态强制停止线程+ (void)exit;// 进入死亡状态注意：一旦线程停止（死亡）了，就不能再次开启任务 线程间通信12- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; NSOperation配合使用NSOperation和NSOperationQueue也能实现多线程编程,具体方式：先将需要执行的操作封装到一个NSOperation对象中然后将NSOperation对象添加到NSOperationQueue中系统会自动将NSOperationQueue中的NSOperation取出来将取出的NSOperation封装的操作放到一条新线程中执行 NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种NSInvocationOperation12345678创建NSInvocationOperation对象- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法注意:默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作,只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation1234567创建NSBlockOperation对象+ (id)blockOperationWithBlock:(void (^)(void))block;通过addExecutionBlock:方法添加更多的操作- (void)addExecutionBlock:(void (^)(void))block;注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 自定义子类继承NSOperation，实现内部相应的方法123456自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 NSOperationQueue的作用NSOperation可以调用start方法来执行任务，但默认是同步执行的如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作123添加操作到NSOperationQueue中- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; 最大并发数的相关方法(并发数:同时执行的任务数)12- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消、暂停、恢复1234567取消队列的所有操作- (void)cancelAllOperations;也可以调用NSOperation的- (void)cancel方法取消单个操作暂停和恢复队列- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序,但不能相互依赖12比如一定要让操作A执行完后，才能执行操作B，可以这么写[operationB addDependency:operationA]; // 操作B依赖于操作A 操作的监听123可以监听一个操作的执行完毕- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"自定义控制器","date":"2017-05-16T08:57:42.000Z","path":"2017/05/16/自定义控制器/","text":"如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系 自定义控制器（带转场动画）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;XMGOneViewController.h&quot;#import &quot;XMGTwoViewController.h&quot;#import &quot;XMGThreeViewController.h&quot;@interface ViewController ()/** 正在显示的控制器 */@property (nonatomic, weak) UIViewController *showingVc;@end@implementation ViewController/** 如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系[a.view addSubview:b.view];[a addChildViewController:b];或者[a.view addSubview:otherView];[otherView addSubbiew.b.view];[a addChildViewController:b]; */- (void)viewDidLoad &#123; [super viewDidLoad]; // 通过addChildViewController添加的控制器都会存在于childViewControllers数组中 [self addChildViewController:[[XMGOneViewController alloc] init]]; [self addChildViewController:[[XMGTwoViewController alloc] init]]; [self addChildViewController:[[XMGThreeViewController alloc] init]];&#125;- (IBAction)buttonClick:(UIButton *)button &#123; // 移除其他控制器的view [self.showingVc.view removeFromSuperview]; // 获得控制器的位置（索引） NSUInteger index = [button.superview.subviews indexOfObject:button]; // 当前控制器的索引 NSUInteger oldIndex = [self.childViewControllers indexOfObject:self.showingVc]; // 添加控制器的view self.showingVc = self.childViewControllers[index]; self.showingVc.view.frame = self.contentView.bounds; [self.contentView addSubview:self.showingVc.view]; // 动画 CATransition *animation = [CATransition animation]; animation.type = @&quot;cube&quot;; animation.subtype = index &gt; oldIndex ? kCATransitionFromRight : kCATransitionFromLeft; animation.duration = 0.5; [self.contentView.layer addAnimation:animation forKey:nil];&#125;/** * 屏幕即将旋转到某个方向时会调用这个方法 */- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration&#123; NSLog(@&quot;%@ willRotateToInterfaceOrientation&quot;, self.class);&#125;@end 级联菜单型的控制器（类似多个相关滚轮选择）的实现：在容器里添加多个子控制器，然后在子控制器之间可以通过代理传递关联关系也可以选择使用多个tableView实现","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"ScrollView中控件悬停和拉伸图片","date":"2017-05-16T08:33:55.000Z","path":"2017/05/16/ScrollView中控件悬停和拉伸图片/","text":"实际开发中有时会需要用到随着拖动视图上部的image会出现拉伸效果，而下面的控件位置不动的情况。可通过监听scrollView滚动来实现123456789101112131415161718192021222324#pragma mark - &lt;UIScrollViewDelegate&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat imageH = self.imageView.frame.size.height; CGFloat offsetY = scrollView.contentOffset.y; NSLog(@&quot;%f&quot;,scrollView.contentOffset.y); if (offsetY &gt;= imageH) &#123; // 将静止的控件添加到控制器的view中，设置Y值为0 CGRect staticF = self.redView.frame; staticF.origin.y = 0; self.staticView.frame = staticF; [self.view addSubview:self.staticView]; &#125; else &#123; // 将红色控件添加到scrollView中，设置Y值为图片的高度 CGRect staticF = self.staticView.frame; staticF.origin.y = 140; self.staticView.frame = staticF; [self.scrollView addSubview:self.staticView]; &#125; CGFloat scale = 1 - (offsetY / 70); scale = (scale &gt;= 1) ? scale : 1; //图片拉伸 self.imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"CodeSnippets","date":"2017-03-27T06:25:22.000Z","path":"2017/03/27/CodeSnippets/","text":"利用Code Snippets可以提高工作效率，而且Code Snippets可以在不同设备之间移动。Xcode中的Code Snippets默认放在下面的目录中：~/Library/Developer/Xcode/UserData/CodeSnippets 定义自己的Code Snippets1.先写好代码片段，占位符的生成语法：&lt;#占位符#&gt;2.将代码片段拖入Xcode右侧代码片段区3.编辑好代码片段信息4.使用（可以通过拖拽和快捷方式使用）","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"masonry","date":"2017-03-27T03:48:28.000Z","path":"2017/03/27/masonry/","text":"把masonry框架载入工程后，请把以下两句宏定义写到头文件内，以便省略该框架语句的“mas_”前缀12#define MAS_SHORTHAND#define MAS_SHORTHAND_GLOBALS约束关系123.equalTo : = (对应NSLayoutRelationEqual) .lessThanOrEqualTo : &lt;= (对应NSLayoutRelationLessThanOrEqual) .greaterThanOrEqualTo : &gt;= (对应NSLayoutRelationGreaterThanOrEqual)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS简单动画","date":"2017-03-20T02:47:09.000Z","path":"2017/03/20/iOS动画/","text":"三种简单动画 首尾动画简单介绍首尾式动画效果（1）开始动画（2）设置动画相关的时间等（3）参与动画的行动（4）提交动画1234567891011[UIView beginAnimations:nil context:nil];//beginAnimations表示此后的代码要“参与到”动画中[UIView setAnimationDuration:2.0];self.headImageView.bounds = rect;// self.headImageView.alpha = 0; ...... setAnimationDuration用来指定动画持续时间[UIView commitAnimations];commitAnimations,将beginAnimation之后的所有动画提交并生成动画 block动画12345[UIView animateWithDuration:0.4 animations:^&#123; //添加动画 &#125; completion:^(BOOL finished) &#123; //动画结束后执行的操作 &#125;]; 序列帧动画12345678//设置动画数组[self.tom setAnimationImages:arrayM];//设置动画播放次数[self.tom setAnimationRepeatCount:1];//设置动画播放时间[self.tom setAnimationDuration:40*0.075];//开始动画[self.tom startAnimating];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Quartz2D","date":"2017-03-20T01:42:33.000Z","path":"2017/03/20/Quartz2D/","text":"Quartz2D(二维绘图引擎),用途：绘制图形、绘制文字、绘制和生成图片（图像）、读取和生成PDF、截图和裁剪图片、自定义UI控件…Quartz2D提供以下几种类型的Graphics Context：Bitmap Graphics ContextPDF Graphics ContextWindow Graphics ContextLayer Graphics ContextPrinter Graphics Context 例：使用Quartz2D自定义view12341.新建一个view，继承自UIView2.实现-(void)drawRect:(CGRect)rect方法，然后在这个方法中先取到跟当前view相关联的图形上下文，然后绘制相应的图形内容，再利用图形上下文将绘制的所有内容渲染显示到view上面注意：-(void)drawrect:(CGRect)rect方法会在view要显示的时候调用，在viewDidLoad,viewWillAppear方法后，viewDidAppear方法前调用;在每次刷新界面时调用，手动调用无效；若要调用该方法，需使用setNeedsDisplay（重绘，全屏）或setNeedsDisplayInRect:(重绘，指定区域)方法。方法一：最根本的方法，其他是在本方法上的简化123456789101112131415161718-(void)drawrect:(CGRect)rect &#123;//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径CGMutablePathRef path = CGPathCreatMutable();//设置起点CGPathMoveToPoint(path,NULL,50,50);(路径，形变，x，y)添加一条线的另一个点CGPathAddLineToPoint(path,NULL,100,100); //3.把路径添加到上下文CGContextAddPath(ctx,path);//4.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法二：对方法一的简化1234567891011121314-(void)drawrect:(CGRect)rect &#123;//rect是控件的bounds//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径//设置起点CGContextMoveToPoint(ctx,50,50);添加一条线的另一个点CGContextAddLineToPoint(ctx,100,100);//3.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法三：贝瑟尔路径（UIKit对Quartz2D的封装）1234567891011-(void)drawrect:(CGRect)rect &#123;//贝瑟尔路径//创建路径UIBezierPath *path = [UIBezierPath bezierPath];//设置起点[path moveToPoint:CGPointMake(50,50)];//设置另一点[path addLineToPoint:CGPointMake(100,100)];//绘制路径[path stroke];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"RunLoop","date":"2017-03-16T01:29:41.000Z","path":"2017/03/16/RunLoop/","text":"一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出这种模型通常被称作 Event Loop(事件循环)。RunLoop是iOS中的Event Loop。Runloop下面有多种模式(Mode)，但是同一时间下只有一种模式可以运行，处理当前模式下事件。Cocoa中的预定义模式有: Default模式：NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)，默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。 Connection模式：NSConnectionReplyMode(Cocoa)，处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。 Modal模式：NSModalPanelRunLoopMode(Cocoa)，处理modal panels事件。 Event tracking模式：UITrackingRunLoopMode(iOS) NSEventTrackingRunLoopMode(cocoa)，描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。 Common模式：NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)，这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。 Mode下包含Source（事件源）、Observer（观察者：监听runloop的状态改变）、Timer（定时器） RunLoop内部逻辑","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"文件下载","date":"2017-03-15T02:36:16.000Z","path":"2017/03/15/文件下载/","text":"HEAD请求：请求头信息，并不返回请求数据体，而只返回请求头信息，常用用于在文件下载中取得文件大小、类型等信息。1234NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:2.0f];//HEAD头(返回文件资源的信息，不返回具体数据)//如果要获取资源的MIMEType，也必须用HEAD，否则，数据会重复下载两次request.HTTPMethod = @&quot;HEAD&quot;;针对文件的分段下载，要先通过HEAD请求获取到文件的信息，让后才能分段下载123456789101112可以通过Range指定每次从网路下载的数据包的大小示例：bytes = 0-499 从0到499的头500个字节bytes = 500-999 从500到999的第二个500字节bytes = 500- 从500字节以后的所有字节bytes = -500 最后500个字节bytes = 500-599,800-899 同时指定几个范围NSString *range = [NSString stringWithFormat:@&quot;Bytes=%lld-%lld&quot;,0,499];NSMutableURLRequest *request= [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:5.0f]; //通过请求头设置数据请求范围.要对请求进行操作,肯定要对请求头做操作! [request setValue:range forHTTPHeaderField:@&quot;Range&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"手势识别","date":"2017-03-14T07:18:16.000Z","path":"2017/03/14/手势识别/","text":"iOS开发中基本手势有六种：点击手势（TapGestureRecognizer）,滑动手势 （SwipeGestureRecognizer）是用于监测滑动的方向的，移动速度快,拖动手势（PanGestureRecognizer）是用于监测偏移的量的，移动速度慢,捏合手势（PinchGestureRecognizer）,旋转手势（RotationGestureRecognizer）,长按手势（LongPressGestureRecognizer）。注意:1.一个手势一般只能对应一个view，但同一个view可以添加多个手势;若要实现一个手势控制多个view，要实现其代理（UIGuidedAccessRestrictionDelegate）,把self作为代理设置给手势 longGesture.delegate = self;，并实现1234-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;2.手势识别是互斥的，比如单击和双击，如果它识别出一种手势，其后的手势将不被识别。所以在添加手势时使用[A requireGestureRecognizerToFail：B]函数，它可以指定当A手势发生时，即便A已经滿足条件了，也不会立刻触发，会等到指定的手势B确定失败之后才触发。1234567891011121314151617181920212223242526272829303132333435363738//点击手势UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapAction:)];//点击次数设置tapGesture.numberOfTapsRequired = 2;//点击手指数目设置tapGesture.numberOfTouchesRequired = 1;//添加手势到目标view上面[self.blueVIew addGestureRecognizer:tapGesture];//滑动手势,一个手势只能控制一个方向UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(swipeAction:)];//设置滑动方向direction方向// swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;//左// swipeGesture.direction = UISwipeGestureRecognizerDirectionRight;//右// swipeGesture.direction = UISwipeGestureRecognizerDirectionUp;//上swipeGesture.direction = UISwipeGestureRecognizerDirectionDown;//下//手指数swipeGesture.numberOfTouchesRequired = 1;//加到view上[self.yellView addGestureRecognizer:swipeGesture];//拖动手势UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panAction:)];[self.blueVIew addGestureRecognizer:panGesture];//捏合手势UIPinchGestureRecognizer *pinGesture = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(pinAction:)];[self.view addGestureRecognizer:pinGesture];//旋转手势UIRotationGestureRecognizer *rotationGesture = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(rotationAction:)];[self.view addGestureRecognizer:rotationGesture];//长按手势UILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longGesture:)];//设置最短长按时间longGesture.minimumPressDuration = 1;[self.view addGestureRecognizer:longGesture];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIView","date":"2017-03-14T06:47:32.000Z","path":"2017/03/14/UIView/","text":"将一个view加到最上层如果想让一个页面显示在一直显示在最上面就把它加到window上面12345678self.navigationController.navigationBar.backgroundColor = [UIColor blueColor]; self.tabBarController.tabBar.backgroundColor = [UIColor orangeColor]; //获取到window UIWindow *window = [UIApplication sharedApplication].keyWindow; UIView *view = [[UIView alloc] init]; view.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); view.backgroundColor = [UIColor redColor]; [window addSubview:view]; 常用属性方法12345678910111213141516171819202122232425262728293031//获得自己的父控件@property (nonatomic, readonly) UIView *superview;//获得自己的所有子控件对象@property (nonatomic, readonly, copy) NSArray *subviews;//控件的ID标识，父控件可以通过tag来找到对应的子控件@property (nonatomic) NSInteger tag;//控件的形变属性，可以设置平移，比例缩放，角度旋转等属性@property (nonatomic) CGAffineTransform *transform;//添加一个子控件- (void)addSubview:(UIView *)view;//使用这个方法添加的子控件会被塞到subviews数组的最后面//可以使用下面的方法调整子控件在subview数组中的顺序 // 将子控件view插入到subviews数组的index位置 - (void)insertSubview:(UIView *)view atIndex:(NSInteger)index; // 将子控件view显示到子控件siblingSubview的下面 - (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview; // 将子控件view显示到子控件siblingSubview的上面 - (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview; // 将子控件view放到数组的最后面，显示在最上面 - (void)bringSubviewToFront:(UIView *)view; // 将子控件view放到数组的最前面，显示在最下面 - (void)sendSubviewToBack:(UIView *)view;//从父控件中移除- (void)removeFromSuperview;//根据tag值找到控件- (UIView *)viewWithTag:(NSInteger)tag;//控件矩形框在父控件中的位置和尺寸(以父控件的左上角为坐标原点)@property (nonatomic) CGRect fram;//控件矩形框的位置和尺寸(以自己左上角为坐标原点，所以bounds的x、y一般为0)@property (nonatomic) CGRect bounds;//控件中点的位置(以父控件的左上角为坐标原点)@property (nonatomic) CGPoint center;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"本地音乐播放","date":"2017-03-14T06:26:41.000Z","path":"2017/03/14/AVAudioPlayer/","text":"播放本地音乐可以用 AVAudioPlayer12345678910//音频播放类@property (nonatomic, strong) AVAudioPlayer *player;//播放进度@property (weak, nonatomic) IBOutlet UIProgressView *playProgress;//音量滑块@property (weak, nonatomic) IBOutlet UISlider *volumeSlider;NSURL *url = [[NSBundle mainBundle] URLForResource:[NSString stringWithFormat:@&quot;%@.mp3&quot;,self.musicArray[index]] withExtension:nil]; self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil];每个AVAudioPlayer只能播放一个url对应的音乐,他虽然有url属性，但是是只读的，不能修改，只能在初始化时赋值1234567891011121314151617将音乐加载到缓冲区[self.player prepareToPlay];开始播放[self.player play];暂停播放（暂停后可以继续播放）[self.player pause];结束播放（结束后就不能继续播放了）[self.player stop];播放音量@property float volume;获取音乐时长@property(readonly) NSTimeInterval duration;获取当前播放时长@property NSTimeInterval currentTime;显示播放进度//通过音频播放时长的百分比,给progressview进行赋值;self.playProgress.progress = self.player.currentTime/self.player.duration;AVAudioPlayerDelegate12345678//播放结束时执行的动作- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer*)player successfully:(BOOL)flag;//解码错误执行的动作- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer*)player error:(NSError *)error;//处理中断的代码- (void)audioPlayerBeginInteruption:(AVAudioPlayer*)player;//处理中断结束的代码- (void)audioPlayerEndInteruption:(AVAudioPlayer*)player;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS碎片","date":"2017-03-14T05:27:32.000Z","path":"2017/03/14/iOS碎片/","text":"UITabBar123456//去掉(覆盖)原生Tabbar的上横线和背景图[[UITabBar appearance] setShadowImage:[self createImageWithColor:[UIColor clearColor]]];[[UITabBar appearance] setBackgroundImage:[self createImageWithColor:[UIColor clearColor]]];//隐藏tabBar的代码vv.hidesBottomBarWhenPushed = YES; UITabBarButton⾥面显⽰什么内容,由对应子控制器的tabBarItem属性来决定有两种方式可以往UITabBarController中添加子控制器 123[tb addChildViewController:c1];tb.viewControllers=@[c1,c2,c3,c4];展示的顺序和添加的顺序一致 UITabBarItem属性1234@property (nonatomic, copy) NSString *title;//标题文字@property (nonatomic, retain) UIImage *image;//图标@property (nonatomic, retain) UIImage *selectedImage;//选中时的图标@property (nonatomic, retain) NSString *badgeValue;//提醒数字 UIScrollView处理scrollView偏移64像素问题,设置1self.automaticallyAdjustsScrollViewInsets = NO; NSUserDefaults使用NSUserDefaults对数据进行保存之后, 它保存到系统的时间是不确定的，会在将来某一时间点自动将数据保存到Preferences文件夹下面，如果需要即刻将数据存储，可以使用12NSUserDefaults *defaults=[NSUserDefaults standardUserDefaults];[defaults synchronize]; 获取程序根目录12345678910方法一：NSString *home = NSHomeDirectory();方法二：（建议使用如下方法动态获取）NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSUserDomainMask：在用户目录下查找YES：代表用户目录的NSDocumentDirectory：查找Documents文件夹拼接文件路径NSString *path = [doc stringByAppendingPathComponent:@&quot;abc.plist&quot;]; Plist12345678910加载plist数据NSBundle的作用：用来访问与之对应的资源包内部的文件，可以用来获得文件的全路径,一个NSBundle对象对应一个资源包（图片、音频、视频、plis等文件）项目中添加的资源都会被添加到主资源包中, [NSBundle mainBundle]关联的就是项目的主资源包 NSBundle *bundle = [NSBundle mainBundle]; // 利用mainBundle获得plist文件在主资源包中的全路径 NSString *file = [bundle pathForResource:@&quot;shops&quot; ofType:@&quot;plist&quot;]; 写入plist [_dataArray writeToFile:file atomically:YES]; 去除NavigationBar下面的线 1self.navigationController.navigationBar.barStyle = UIBaselineAdjustmentNone; 重写方法121.重写对象的-(void)description;方法，可以自定义NSLog输出。2.重写-(void)dealloc;方法，自定义销毁（要保证super dealloc是重写方法里的最后一句） NSArray121.componentsSeparatedByString:以给定的字符串将目标字符串切分成数组2.componentsJoinedByString:以给定字符串将数组合成一个字符串 NSString1234567891011121314151617181.isEqualToString:比较两个字符串的内容是否相同2.compare:将接收对象和传递过来的字符串逐一比较3.compare:options:不区分大小写的比较（NSCaseInsensitiveSearch:不区分大小写 NSLiteralSearch:进行完全比较，区分大小写NSNumericSearch:比较字符串字符个数）4.-(BOOL)hasPrefix:(NSString)aString:检查字符串是否以另一个字符串开头5.-(BOOL)hasSuffix:(NSString)aString: 检查字符串是否以另一个字符串结尾6.-(NSRange)rangeOfString:(NSString)aString:检查字符串里是否包含其他字符串7.-(void)appendString:(NSString)aString:添加字符串8.-(void)appendFormat:(NSString)format,…:添加字符串9.-(void)deleteCharactersInRange:(NSRange)aRange:从字符串中删去一段10.initWithContentsOfFile:encoding:error:打开指定路径上的文本，读取文件内容，并使用文件内容初始化一个字符串例：NSError *error =nil;NSString *string = [[NSString alloc] initWithContentsOfFile:@&quot;/tmp/wprds.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error];if(nil != error)&#123; NSLog(@&quot;%@&quot;,[error localizedDescription]);&#125; ** Staticstatic的作用：1.修饰局部变量让局部变量只初始化一次局部变量在程序中只有一份内存并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）2.修饰全局变量全局变量的作用域仅限于当前文件","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Xcode工程配置","date":"2017-03-14T02:39:35.000Z","path":"2017/03/14/Xcode工程配置/","text":"查找Xcode里的iOS版本包路径1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 权限获取1234567891011添加一个属性，输入Privacy后就会出现自动提示:描述字符串自己随意填写就可以,但是一定要填写，不然会引发包无效的问题，导致上传打包后构建版本一直不显示。麦克风权限 - Microphone Usage Description - 是否允许此App使用你的麦克风？相机权限 - Camera Usage Description - 是否允许此App使用你的相机？相册权限 - Photo Library Usage Description - 是否允许此App访问你的媒体资料库？通讯录权限 - Contacts Usage Description - 是否允许此App访问你的通讯录？蓝牙权限 - Bluetooth Peripheral Usage Description - 是否许允此App使用蓝牙？语音转文字权限 - Speech Recognition Usage Description - 是否允许此App使用语音识别？日历权限 - Calendars Usage Description - 是否允许此App使用日历？定位权限 - Location When In Use Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据定位权限 - Location Always Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"单例","date":"2017-03-14T02:30:14.000Z","path":"2017/03/14/单例/","text":"GCD方式123456789101112131415//ViewController类的单例（调用单例时直接调这个方法）+ (instancetype)sharedInstance&#123; static ViewController *singleton = nil; //是否存在的判断 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil] instantiateViewControllerWithIdentifier:@&quot;musicVC&quot;]; 或 singleton = [[ViewController alloc] init]; //自定义处理 &#125;); return singleton;&#125; 经典方式重写allocWithZone方法XXX.m1234567891011121314id _XXX(类名);//alloc方法的底层方法+(id)allocWithZone:(struct _NSZone *)zone&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [super allocWithZone:zone]; //其他自定义处理 &#125; &#125; &#125;&#125; XXX.h1+(instancetype)sharedXXX; XXX.m1234567891011+(instancetype)sharedXXX&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [[self alloc] init]; &#125; &#125; &#125; return _XXX;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIDynamic物理引擎","date":"2017-03-14T01:43:46.000Z","path":"2017/03/14/UIDynamic物理引擎/","text":"UIDynamic隶属于UIKit框架可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象(重力、弹性碰撞等现象)UIDynamic使用步骤：1.创建一个物理仿真器（顺便设置仿真范围）1UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];//ReferenceView:仿真范围2.创建相应的物理仿真行为（顺便添加物理仿真元素）123456//重力行为UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];//Items:要进行行为的对象//碰撞检测行为UICollisionBehavior *collision = [[UICollisionBehavior alloc] initWithItems:@[self.blueView]];//将参照视图的边框转变为碰撞检测的边界collision.translatesReferenceBoundsIntoBoundary = YES；3.将物理仿真行为添加到物理仿真器中，开始仿真1[animator addBehavior:grvity]; UIDynamic提供了以下几种物理仿真行为:UIGravityBehavior — 重力行为UICollisionBehavior — 碰撞行为:为Item与边界以及Item之间添加碰撞效果。UISnapBehavior — 捕捉行为UIPushBehavior — 推动行为UIAttachmentBehavior — 附着行为UIDynamicItemBehavior — 动力元素行为:配置一些公用的属性，与其他的Dynamic Behavior共同配合 常用属性方法12345678910111213141516//属性@property (nonatomic, readonly) UIView* referenceView;//参照视图@property (nonatomic, readonly, copy) NSArray* behaviors;//添加到物理仿真器中的所有物理仿真行为@property (nonatomic, readonly, getter = isRunning) BOOL running;//判定animator中是否还有行为正在执行@property (nonatomic, assign) id &lt;UIDynamicAnimatorDelegate&gt; delegate;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）//方法- (void)addBehavior:(UIDynamicBehavior *)behavior;//添加指定的行为动画- (void)removeBehavior:(UIDynamicBehavior *)behavior;//移除指定的行为动画- (void)removeAllBehaviors;//移除所有的行为- (NSTimeInterval)elapsedTime;//行为执行的时间，需要注意的是如果我们对同一个行为进行添加和移除操作时，时间会累积。- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;//如果想要改变center或者transform必须调用这个方法 ,否则改变是无效的. //代理方法- (void)dynamicAnimatorWillResume:(UIDynamicAnimator *)animator;//add行为时调用- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator;//remove行为时调用","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"隐藏文件","date":"2017-03-10T09:28:44.000Z","path":"2017/03/10/隐藏文件/","text":"在Windows系统下 隐藏rar到jpg图片中去：1.把要隐藏的文件生成压缩包2.新建一个文本文件，写入代码：12copy /b 图片名.jpg+压缩包名.rar 生成的图片名.jpg 3.将文本文件后缀改为bat4.运行bat文件 取出隐藏的文件：将jpg改为rar，然后解压 12copy /b 1+2 3该代码是将1，2两个文件进行连接（可以合并mp3,txt,,,,多种格式）,合并完1是显示的格式","tags":[{"name":"其他","slug":"其他","permalink":"https://Misaka-NO10032.github.io/tags/其他/"}]},{"title":"UIScrollView","date":"2017-03-10T08:01:52.000Z","path":"2017/03/10/UIScrollView/","text":"属性1234567891011121314151617181920212223@property(nonatomic) CGPoint contentOffset; 表示UIScrollView当前显示的位置（其实就是内容左上角与scrollView左上角的间距值）@property(nonatomic) CGSize contentSize; 表示UIScrollView内容的尺寸@property(nonatomic) UIEdgeInsets contentInset; 这个属性能够在UIScrollView的4周增加额外的滚动区域，一般用来避免scrollView的内容被其他控件挡住@property(nonatomic) BOOL bounces;设置UIScrollView是否需要弹簧效果@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置UIScrollView是否能滚动@property(nonatomic) BOOL showsHorizontalScrollIndicator;是否显示水平滚动条@property(nonatomic) BOOL showsVerticalScrollIndicator;是否显示垂直滚动条@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled;是否设置分页显示 UIScrollViewDelegate滚动1234567891011121314滚动开始- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;滚动中。。。- (void)scrollViewDidScroll:(UIScrollView *)scrollView;滚动结束- (void)scrollViewDidEndDragging:(UIscrollView *)scrollView willDecelerate:(BOOL)decelerate;开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;减速停止- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;是否支持滑动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;滑动到顶部时调用该方法- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 缩放123456789101112缩放实现步骤:1. 设置UIScrollView的id&lt;UISCrollViewDelegate&gt; delegate代理对象2. 设置minimumZoomScale ：缩小的最小比例3. 设置maximumZoomScale ：放大的最大比例4. 让代理对象实现下面的方法，返回需要缩放的视图控件 - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;跟缩放相关的其他代理方法缩放开始的时候调用 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view正在缩放的时候调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView UIPageControl12345678910一共有多少页@property(nonatomic) NSInteger numberOfPages;当前显示的页码@property(nonatomic) NSInteger currentPage; 只有一页时，是否需要隐藏页码指示器@property(nonatomic) BOOL hidesForSinglePage;其他页码指示器的颜色@property(nonatomic,retain) UIColor *pageIndicatorTintColor;当前页码指示器的颜色@property(nonatomic,retain) UIColor *currentPageIndicatorTintColor;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIButton","date":"2017-03-10T07:09:01.000Z","path":"2017/03/10/UIButton/","text":"12345678获得按钮的文字- (NSString *)titleForState:(UIControlState)state; 获得按钮的文字颜色- (UIColor *)titleColorForState:(UIControlState)state;获得按钮内部的小图片- (UIImage *)imageForState:(UIControlState)state;获得按钮的背景图片- (UIImage *)backgroundImageForState:(UIControlState)state;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UITableView","date":"2017-03-10T06:56:37.000Z","path":"2017/03/10/UITableView/","text":"去掉多余的分割线1self.tableView.tableFooterView = [[UIView alloc] init]; 刷新12345678刷新全部数据[self.tableView reloadData];刷新索引[self.tableView reloadSectionIndexTitles];刷新某个Section[self.tableView reloadSections:(nonnull NSIndexSet *) withRowAnimation:(UITableViewRowAnimation)];刷新某行[self.tableView reloadRowsAtIndexPaths:(nonnull NSArray&lt;NSIndexPath *&gt; *) withRowAnimation:(UITableViewRowAnimation)];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIResponder相关","date":"2017-03-10T02:48:15.000Z","path":"2017/03/10/UIResponder/","text":"UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events,如插入耳机调节音量触发的事件)。UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder,所以这些类都可以响应事件。1234567891011121314//下一个接收事件的响应者@property(nonatomic, readonly, nullable) UIResponder *nextResponder;- (nullable UIResponder*)nextResponder;//是否成为第一响应者@property(nonatomic, readonly) BOOL canBecomeFirstResponder;//default is NO- (BOOL)canBecomeFirstResponder;//default is NO- (BOOL)becomeFirstResponder;//是否能取消第一响应者@property(nonatomic, readonly) BOOL canResignFirstResponder;//default is YES- (BOOL)canResignFirstResponder;//default is YES- (BOOL)resignFirstResponder;//是否是第一响应者@property(nonatomic, readonly) BOOL isFirstResponder;- (BOOL)isFirstResponder; 触摸事件(Touch Events)12345678910//触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; //触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸中断- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//3D触摸- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1); 运动事件(Motion Events)123456//运动开始- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动中断- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0); 远程控制事件(Remote Control Events）12//远程控制- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0); UITouch当用户用手指触摸屏幕时，系统会为每根手指创建一个与之关联的UITouch对象UITouch保存着跟手指相关的信息，比如触摸的位置、时间、阶段；当手指移动时，系统会更新与之相对应的UITouch对象，使之能够一直保存该手指即时的触摸位置1234- (CGPoint)locationInView:(UIView *)view;函数返回触摸点相对view这个视图的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置- (CGPoint)previousLocationInView:(UIView *)view;该方法返回了前一个触摸点相对view的值 UITouch属性12345678910//触摸所在的窗口@property (nonatomic, readonly, retain) UIWindow *window;//触摸所在的view@property (nonatomic, readonly, retain) UIView *view;//短时间内点击屏幕的次数，可根据tapCount判断单击、双击或更多点击@property (nonatomic, readonly,) NSUInteger tapCount;//记录了触摸事件产生或变化时的时间，单位 （秒）@property (nonatomic, readonly) NSTimeInterval timestamp;//当前触摸事件所处的状态@property (nonatomic, readonly) UITouchPhase phase; UIEventUIEvent：称为事件对象，记录事件产生的时刻和类型.每产生一个事件，就会产生一个UIEvent对象常见属性12345//事件类型@property(nonatomic, readonly) UIEventType type;@property(nonatomic, readonly) UIEventSubtype subtype;//事件产生的时间@property(nonatomic, readonly) NSTimeInterval timestamp; UIEvent还提供相应的方法可以获得在某个view上面的触摸对象（UITouch）12- (NSSet *)allTouches；//获得全部UITouch- (NSSet *)touchesForView:(UIView *)view;//获取view上的UITouch","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]}]