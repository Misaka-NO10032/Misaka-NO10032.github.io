[{"title":"AVFoundation-播放和录制音频","date":"2018-02-22T01:38:56.000Z","path":"2018/02/22/AVFoundation-播放和录制音频/","text":"音频会话音频会话在应用程序和操作系统之间扮演者中间人的角色。默认音频会话来自于以下一些预配置： 激活了音频播放，但是音频录制未激活 当用户切换响铃/静音开关到“静音”模式时，应用程序播放的所有音频都会消失 当设备显示解锁屏幕时，应用程序的音频处于静音状态 当应用程序播放音频时，所有后台播放的音频都会处于静音状态对于一些实际需求，我们可以通过“分类”来自定义 音频会话分类 分类 作用 是否允许混音 音频输入 音频输出 是否受静音/锁屏控制 Ambient (AVAudioSessionCategoryAmbient) 游戏、效率应用程序 是 是 是 Solo Ambient（默认） (AVAudioSessionCategorySoloAmbient) 游戏、效率应用程序 是 是 Playback (AVAudioSessionCategoryPlayback) 音频和视频播放器 可选 是 Record (AVAudioSessionCategoryRecord) 录音机、音频捕捉 是 Play and Record (AVAudioSessionCategoryPlayAndRecord) VoIP、语音聊天 可选 是 是 Audio Processing (AVAudioSessionCategoryAudioProcessing) 离线会话和处理 Multi-Route (AVAudioSessionCategoryMultiRoute) 使用外部硬件的高级A/V应用程序 是 是 上述分类提供的几种常见行为可以满足大部分的应用程序需要，如有需要更加复杂的功能，其中一些分类可以通过使用options和modes方法进一步自定义开发。options可以让开发者使用一些附加行为，如使用Playback分类后，应用程序允许将输出音频和背景声音进行混合。modes可以通过引入被定制的行为进一步对分类进行修改以满足一些特殊的需求。 配置音频会话音频会话在应用程序的生命周期中是可以改的，但通常我们只需要在程序启动时配置一次就好12345678910111213141516- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;//配置音频会话 AVAudioSession *session = [AVAudioSession sharedInstance]; NSError *error; //设置音频会话类型 if (![session setCategory:AVAudioSessionCategoryPlayback error:&amp;error]) &#123; //错误处理 NSLog(@&quot;Category Error: %@&quot;, [error localizedDescription]); &#125; //激活会话 if (![session setActive:YES error:&amp;error]) &#123; //错误处理 NSLog(@&quot;Activation Error: %@&quot;, [error localizedDescription]); &#125; return YES;&#125;AVAudioSession提供了与应用程序音频会话交互的接口，所以开发者需要取得指向该单例的指针。通过设置合适的分类，开发者可以为音频的播放指定需要的音频会话，其中定制一些行为。最后告知该音频会话激活该配置。1后台播放配置：info -&gt; 添加 Required background modes（Array）-&gt; 添加 App plays audio or streams audio/video using AirPlay 使用AVAudioPlayer播放音频 AVAudioPlayer类的实例提供了一种简单的从文本或内存中播放音频的方法。 注意：不支持网络流播放 创建AVAudioPlayer12345678910111213141516NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&quot;rock&quot; withExtension:@&quot;mp3&quot;];NSError *error;//通过本地音频的url创建AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:fileURL error:&amp;error];//通过本地音频的data创建AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithData:rockData error:&amp;error];if (player) &#123; player.numberOfLoops = -1; // 循环次数，-1无限循环 player.enableRate = YES;//是否能修改播放速率 player.rate = 1.0;//播放速率 [player prepareToPlay];&#125; else &#123; NSLog(@&quot;Error creating player: %@&quot;, [error localizedDescription]);&#125; 调用prepareToPlay方法可以将音频预加载到缓冲区。当调用play方法时该方法会隐性调用，不过在创建AVAudioPlayer时调用可以降低调用play方法和听到声音输出之间的延时。 对播放进行控制方法 play：播放 pause：暂停 stop：停止 pause、stop都会停止播放，当调用play时停止的音频也都会继续播放，两者的作用从应用程序外看来是一样的，但是主要区别在底层处理上。区别在于，stop会撤销调用prepareToPlay时所作的设置，而pause并不会。 属性 volume：音量0.0～1.0 pan：允许使用立体声播放声音-1.0（极左）～1.0（极右），默认值0.0（居中） rate：播放速率0.5～2.0 numberOfLoops：循环播放，-1无限循环多个播放器实例同步123456789- (void)play &#123; if (!self.playing) &#123; NSTimeInterval delayTime = [self.players[0] deviceCurrentTime] + 0.01; for (AVAudioPlayer *player in self.players) &#123; [player playAtTime:delayTime]; &#125; self.playing = YES; &#125;&#125; 要对多个播放器实例进行同步，需要先捕捉当前设备时间并添加一个小延时，这样就会具有一个从开始播放时间计算的参照时间。通过每个实例调用playAtTime方法并传递延时参照时间，遍历播放器数组并开始播放。这样就保证了这些播放器在音频播放时始终保持紧密同步。 处理中断事件iPhone上应用程序运行过程中，可能会遇上中断事件，如电话呼入等。注册中断通知12345678910NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];[nsnc addObserver:self selector:@selector(handleInterruption:) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];//AVAudioSessionInterruptionNotification 中断通知//注销通知- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;中断处理1234567891011121314151617181920212223- (void)handleInterruption:(NSNotification *)notification &#123; NSDictionary *info = notification.userInfo; AVAudioSessionInterruptionType type = [info[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue]; if (type == AVAudioSessionInterruptionTypeBegan) &#123; //AVAudioSessionInterruptionTypeBegan //中断开始的后续自定义操作 [self stop]; if (self.delegate) &#123; [self.delegate playbackStopped]; &#125; &#125;else &#123; //AVAudioSessionInterruptionTypeEnded //中断结束后的后续自定义操作 AVAudioSessionInterruptionOptions options = [info[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue]; if (options == AVAudioSessionInterruptionOptionShouldResume) &#123; //中断结束，可以恢复播放 [self play]; if (self.delegate) &#123; [self.delegate playbackBegan]; &#125; &#125; &#125;&#125; 对线路改变的响应在iOS设备上添加或移除音频输入、输出线路时，会发生线路改变。注册线路变化通知12345678910//注册通知，接收AVAudioSessionRouteChangeNotification，处理线路变更NSNotificationCenter *nsnc = [NSNotificationCenter defaultCenter];[nsnc addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];//注销通知- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;判断通知原因并进行处理12345678910111213141516- (void)handleRouteChange:(NSNotification *)notification &#123; NSDictionary *info = notification.userInfo; AVAudioSessionRouteChangeReason reason = [info[AVAudioSessionRouteChangeReasonKey] unsignedIntValue]; if (reason == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123; AVAudioSessionRouteDescription *previousRoute = info[AVAudioSessionRouteChangePreviousRouteKey]; AVAudioSessionPortDescription *previousOutput = previousRoute.outputs[0]; NSString *portType = previousOutput.portType; if ([portType isEqualToString:AVAudioSessionPortHeadphones]) &#123; //判断时耳机断开后，进行操作 [self stop]; [self.delegate playbackStopped]; &#125; &#125;&#125;在收到设备断开连接的通知后，需要向userInfo字典提出请求，以获得其中用于描述前一个线路的AVAudioSessionRouteDescrription。线路的描述信息整合在一个输入NSArray和一个输出NSArray中。数组中的元素都是AVAudioSessionPortDescrription的实例，用于描述不同的I/O接口属性。从线路描述中找出第一个输出接口并判断其是否为耳机接口。如果是，则停止播放。这样当我们断开耳机后，音频播放就会如期望般停止。 使用AVAudioRecorder录制音频创建AVAudioRecorder创建AVAudioRecorder实例时要提供一些信息，分别是： 用于表示音频流写入文件的本地文件URL 包含用于配制录音会话键值信息的NSDictionary对象 用于捕捉初始化阶段各种错误的NSError指针123456789101112131415161718192021NSString *tmpDir = NSTemporaryDirectory();NSString *filePath = [tmpDir stringByAppendingPathComponent:@&quot;memo.caf&quot;];NSURL *fileURL = [NSURL fileURLWithPath:filePath];NSDictionary *settings = @&#123; AVFormatIDKey : @(kAudioFormatAppleIMA4), AVSampleRateKey : @44100.0f, AVNumberOfChannelsKey : @1, AVEncoderBitDepthHintKey : @16, AVEncoderAudioQualityKey : @(AVAudioQualityMedium) &#125;;NSError *error;self.recorder = [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:&amp;error];if (self.recorder) &#123; self.recorder.delegate = self; self.recorder.meteringEnabled = YES; [self.recorder prepareToRecord];&#125; else &#123; NSLog(@&quot;Error: %@&quot;, [error localizedDescription]);&#125; prepareToRecord方法同AVAudioPlayer的该方法，在创建时调用可以将录制启动时间的延时降到最小。设置字典的指定键值信息，在有完整的定义。下面介绍一些通用的键值音频格式AVFormatIDKey定义了写入内容的音频格式，下面的常量都是常用的音频格式所支持的值： kAudioFormatLinearPCM kAudioFormatMPEG4AAC kAudioFormatAppleLossless kAudioFormatAppleIMA4 kAudioFormatiLBC kAudioFormatULawkAudioFormatLinearPCM会将未压缩的音频流写入到文件中，保真最高，相应的文件也最大。kAudioFormatMPEG4AAC或kAudioFormatAppleIMA4的压缩格式会显著缩小文件，还能保证高质量的音频内容。 注意：指定的音频格式一定要和URL参数定义的文件类型兼容。.caf通常是最好的容器格式，因为它和内容无关并可以保存Core Audio支持的任何音频格式。 采样率AVSampleRateKey用于定义录音器的采样率。采样率定义了对输入的模拟音频信号每一秒内的采样率。在录制音频的质量及最终的文件大小方面，采样率扮演着至关重要的角色。使用低采样率，比如8kHz，会导致粗粒度、AM广播类型的录制效果，不过文件会比较小；使用44.1kHz的采样率（CD质量的采样率）会得到非常高质量的内容，不过文件就比较大。对于使用什么采样率最好没有一个明确的定义，不过开发者应该尽量使用标准的采样率，比如8000，16000，22050或44100.最终是我们的耳朵在进行判断。通道数AVNumberOfChannelsKey用于定义记录音频内容的通道数。指定默认值为1意味着使用单声道录制，设置为2意味着使用立体声录制。除非使用外部硬件进行录制，否则通常应该创建单声道录音。 控制录音过程AVAudioRecorder包含一些方法可以支持无限时长的录制，比如在未来某一时间点开始录制或录制指定长度的内容等。开发者甚至可以暂停录制并在之后从这个停止的地方继续重启录制。方法 record：录制 pause：暂停 stop：停止 保存录音内容12345678910111213141516171819202122232425- (void)saveRecordingWithName:(NSString *)name completionHandler:(THRecordingSaveCompletionHandler)handler &#123; NSTimeInterval timestamp = [NSDate timeIntervalSinceReferenceDate]; NSString *filename = [NSString stringWithFormat:@&quot;%@-%f.m4a&quot;, name, timestamp]; NSString *docsDir = [self documentsDirectory]; NSString *destPath = [docsDir stringByAppendingPathComponent:filename]; NSURL *srcURL = self.recorder.url; NSURL *destURL = [NSURL fileURLWithPath:destPath]; NSError *error; BOOL success = [[NSFileManager defaultManager] copyItemAtURL:srcURL toURL:destURL error:&amp;error]; if (success) &#123; handler(YES, [THMemo memoWithTitle:name url:destURL]); [self.recorder prepareToRecord]; &#125; else &#123; handler(NO, error); &#125;&#125;- (NSString *)documentsDirectory &#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); return [paths objectAtIndex:0];&#125; 使用Audio Metering对音频进行测量AVAudioRecorder和AVAudioPlayer中最强大和实用的功能就是对音频进行测量。Audio Metering可以让开发者读取音频的平均分贝和峰值分贝，并使用这些数据以可视化方式将声音的大小呈现给用户。两个类都使用12- (float)peakPowerForChannel:(NSUInteger)channelNumber; - (float)averagePowerForChannel:(NSUInteger)channelNumber; 来获取峰值和均值。这个值的范围从0Db（最大分贝）到-160dB（最小分贝或静音） 在读取这些值之前，首先要设置meteringEnabled的属性为YES才可以支持对音频进行测量。每次需要读取值时，首先通过调用updateMeters方法才能获得最新的值。 关于声音计量展示需要注意的是，这么做会增加开销。启用计量功能会导致一些额外计算，会影响设备的耗电量。而且绘图展示用Quartz的话会占用CPU资源。所以如果要录制长时间的音频可以考虑仅用音频计量功能，或者选择更高效的绘制方法，比如使用OpenGL ES。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"AVFoundation入门","date":"2018-02-21T08:54:44.000Z","path":"2018/02/21/AVFoundation入门/","text":"视频文件基础知识 FPS：视频的帧率，指视频文件一秒钟内所能展示的帧数。常见的帧率有24FPS、25FPS和30FPS。 视频有许多通用尺寸，常见的是16:9，即每16个水平像素对应9个垂直像素，在这一宽高比之下常见的视频尺寸是1280x720和1920x1080.如果每一个像素点使用8位的RGB色彩空间，就意味着红色占8位，绿色占8位，蓝色占8位，下表展示了未压缩视频在30FPS帧率的情况下，需要的存储空间。 颜色 分辨率 帧率 MB/s GB/h 24位 1280x720 30FPS 79MB/s 278GB/h 24位 1920x1080 30FPS 178MB/s 625GB/h 由此可见，在当前阶段未压缩的视频传输是不可取的，于是我们需要压缩技术。 数字媒体压缩 色彩二次抽样我们的眼睛对亮度的敏感度要高于颜色，所以我们可以将图片分离成亮度和色彩通道，再大幅度的减少存储在每个像素里的颜色信息，而不至于使图片的质量严重受损。这个减少颜色数据的过程就称为色彩二次抽样。在摄像头规范和其他视频设备硬件或软件中提到的4:4:4、4:2:2以及4:2:0时，这些值就表示这些设备使用的色彩二次抽样的参数。格式写作J:a:b具体含义如下：J：几个关联色块（一般为4个）中所包含的像素数a：用来保存位于第一行中的每J个像素的色度像素个数b：用来保存位于第二行中的每J个像素的附加像素个数为了维持图片质量，每个像素点都需要有各自的亮度值，却不一定需要色度值。在所有的格式下，每个像素的全部亮度信息都会被保存下来，在4:4:4的情况下全部的色彩信息也会被保存下来；在4:2:2的情况下，色彩信息为每两个水平像素的平均值，即亮度和色度比率为2:1；在4:2:0的情况下，色彩信息为水平和垂直两个方向的4个像素的平均值，亮度和色度的比率就是4:1.色彩二次抽样一般发生在取样时，一些专业相机以4:4:4的参数捕捉图像，但大部分情况下对图片的拍摄是使用4:2:2的方式进行的。iPhone的摄像头通常是4:2:0进行拍摄的。当以色彩作为核心或在生产后期校正颜色的时候，如果色彩方面出现了衰减，那会成为一个棘手的问题。由于我们的色彩信息是通过多个像素点平均得来的，噪声点和其他一些失真问题也会出现在图片上。 编解码器压缩 大部分的音频和视频都是使用编解码器（codec）来压缩的，编解码器这个术语是由编码器/解码器结合简写得来的（encoder/decoder）。编解码器既可以进行无损压缩也可以进行有损压缩。无损压缩编解码器以一种可以完美重构的方式对媒体文件进行压缩，使其成为无论编辑还是发布都比较理想的文件，有时候也作为归档文件使用。例如zip和gzip压缩。有损压缩编解码器在压缩过程中会有部分数据损失掉，但是有损压缩的目的是使用psycho-acoustic或psycho-visual模式作为一种方法来减少媒体内容中的冗余数据，这样会使原文件质量的损耗达到最小。 视频编解码器对视频编解码而言，AV Foundation提供有限的编解码器集合，具体到视频文件，主要可以归结为H.264和Apple ProRes。H.264H.264与其他MPEG压缩一样，通过空间和时间两个维度缩小视频文件的尺寸。 空间：压缩独立视频帧，被称为帧内压缩。通过消除包含在每个独立视频帧的色彩及结构中冗余信息来进行压缩，因此可以在不降低图片质量的情况下尽可能缩小尺寸。这与JEPG压缩原理类似。帧内压缩也可以作为有损压缩算法，但通常用于对原始图片的一部分进行处理以生成极高质量的照片。通过这一过程创建的帧称为I-frames。 时间：通过以组为单位的视频帧压缩冗余数据，称为帧间压缩。在帧间压缩中，很多帧被组合在一起作为一组图片（简称GOP），对于GOP所存在的时间维度的冗余可以被消除。如果想象视频文件中的典型场景，就会有一些特定运动元素的概念，比如行驶的汽车或街上走路的行人，场景的背景环境通常是固定的。固定的背景环境就代表一个时间维度上的冗余，这个冗余就可以通过压缩方式进行消除。下图给出了存储在GOP中的3个不同类型的帧。 I-frames：这些帧都是一些单独的帧或关键帧，包含创建完整图片所需的所有数据。每个GOP都正好有一个I-frames。由于它是一个独立帧，其尺寸是最大的，但也是解压最快的。 P-frames：称为预测帧，是从基于最近I-frames或P-frames的可预测的图片进行编码得到的。P-frames可以引用最近的预测P-frames或一组I-frames。你将会经常看到这些被称为“reference frames”的帧，临近的P-frames和B-frames都可以对其进行引用。 B-frames：称为双向帧，是基于使用之前和之后的帧信息进行编码后得到的帧。几乎不需要存储空间，但其解压过程会耗费较长的时间，因为它依赖于周围其他的帧。Apple ProResProRes是有损编解码器，但它具有最高的编解码质量。ProRes编解码器只在OS X上可用。如果开发者只针对iOS进行开发，那只能使用H.264. 音频编解码器AAC高级音频编码（AAC）是H.264标准相应的音频处理方式，目前已成为音频流和下载的音频资源中最主流的编码方式。 注意：AV Foundation提供MP3数据解码的支持，但是不支持对其进行编码。 容器格式扩展名为.mov、.m4v、.mpg、.m4a等，我们通常将这些类型都认为是文件格式，但其正确定义应该是这些类型的都是文件的容器格式（container format）。容器格式是元文件格式，从更高的角度看，可以将容器格式视为包含一种或更多种媒体类型（以及描述其内容的元数据）的目录。比如QuickTime文件可以包含多种不同的媒体类型，包括视频、音频、字幕和章节信息等。在AV Foundation的使用中常遇到的是QuickTime和MPEG-4。QuickTime是苹果公司在更宏观QuickTime架构中定义的最常用格式。具有非常高的可靠性并且是一种有着非常清晰定义的格式，被专业领域人士和普通消费者广泛使用。MPEG-4是从QuickTime规范中直接派生出来的一种行业标准格式，其容器格式的官方文件扩展名是.mp4。 文本转语音打印设备支持的语言类型123for (AVSpeechSynthesisVoice *voice in [AVSpeechSynthesisVoice speechVoices]) &#123; NSLog(@&quot;--- Language: %@&quot;, voice.language); &#125;文本转语音的Dome12345678910111213//语句 AVSpeechUtterance *utterance = [[AVSpeechUtterance alloc] initWithString:@&quot;hello world!&quot;]; utterance.voice = [AVSpeechSynthesisVoice voiceWithLanguage:@&quot;zh-CN&quot;];//合成后的声音 utterance.rate = (AVSpeechUtteranceMinimumSpeechRate + AVSpeechUtteranceDefaultSpeechRate) / 2.0;//播放语音内容的速率 // AVSpeechUtteranceMinimumSpeechRate最小速率 = 0.0 // AVSpeechUtteranceMaximumSpeechRate最大速率 = 1.0 // AVSpeechUtteranceDefaultSpeechRate默认速率 utterance.pitchMultiplier = 1.5f;//音调高低，一般介于0.5（低音调）和2.0（高音调）之间 utterance.postUtteranceDelay = 1.0f;//停顿，让语音合成器在播放下一语句之前有短时间的暂停 utterance.volume = 0.8;//音量//语音合成器 AVSpeechSynthesizer *synthesizer = [[AVSpeechSynthesizer alloc] init]; [synthesizer speakUtterance:utterance];AVSpeechSynthesizer起到队列的作用，提供了接口供控制和监控正在进行的语音播放。AVSpeechUtterance负责具体的文本到语音的转换","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"正则表达式","date":"2018-01-10T03:02:07.000Z","path":"2018/01/10/正则表达式/","text":"正则表达式 正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特殊字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘\\(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 &#124; 指明两项之间的一个选择。要匹配 &#124;，请使用 \\&#124;。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"UICollectionView及自定义布局","date":"2017-08-06T05:53:50.000Z","path":"2017/08/06/UICollectionView及自定义布局/","text":"UICollectionView继承自UIScrollView,系统提供UICollectionViewFlowLayout流水布局(支持横／纵向滚动),此外可以根据需求自定义布局。 UICollectionView使用基础123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#import &quot;ViewController.h&quot;@interface ViewController ()&lt;UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&gt;/* collectionView */@property (nonatomic, strong) UICollectionView *cView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.cView];&#125;- (UICollectionView *)cView &#123; if (!_cView) &#123; //流水布局 UICollectionViewFlowLayout *layout = [UICollectionViewFlowLayout new]; //设置单元格大小 layout.itemSize = CGSizeMake(20, 20); //设置滚动方向 layout.scrollDirection = UICollectionViewScrollDirectionVertical;//垂直 //设置分区间距 layout.sectionInset = UIEdgeInsetsMake(5, 10, 15, 20); //设置最小单元格行间距 layout.minimumLineSpacing = 3; //设置最小单元格列间距 layout.minimumInteritemSpacing = 6; UICollectionView *cView = [[UICollectionView alloc] initWithFrame:CGRectMake(0, 74, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height-84) collectionViewLayout:layout]; cView.backgroundColor = [UIColor orangeColor]; //设置垂直方向总是可以滚动 cView.alwaysBounceVertical = YES; //设置代理 cView.delegate = self; cView.dataSource = self; //注册cell [cView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellID&quot;]; //注册页眉 [cView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;Header&quot;]; //注册页脚 [cView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;Footer&quot;]; _cView = cView; &#125; return _cView;&#125;//设置有几个分区- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView &#123; return 2;&#125;//设置每个分区多少Item- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; if (section == 0) &#123; return 80; &#125; return 40;&#125;//设置页眉页脚- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath &#123; UICollectionReusableView *reusableView = nil; //页眉 if (kind == UICollectionElementKindSectionHeader) &#123; reusableView = [_cView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;Header&quot; forIndexPath:indexPath]; reusableView.backgroundColor = [UIColor purpleColor]; &#125; //页脚 if (kind == UICollectionElementKindSectionFooter) &#123; reusableView = [_cView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@&quot;Footer&quot; forIndexPath:indexPath]; reusableView.backgroundColor = [UIColor redColor]; &#125; return reusableView;&#125;//设置Item- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellID&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor blueColor]; return cell;&#125;//选中Item- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@&quot;分区：%ld,索引：%ld&quot;,indexPath.section,indexPath.item);&#125;#pragma mark - UICollectionViewDelegateFlowLayout//控制单元格大小- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.section == 1 &amp;&amp; indexPath.item == 1) &#123; return CGSizeMake(50, 40); &#125; return CGSizeMake(20, 20);&#125;//控制分区留白区域- (UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section &#123; if (section == 1) &#123; return UIEdgeInsetsMake(25, 25, 25, 25); &#125; return UIEdgeInsetsMake(0, 0, 0, 0);&#125;//控制指定分区最小行间距- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section &#123; if (section == 0) &#123; return 20; &#125; return 10;&#125;//控制指定分区最小列间距- (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section &#123; if (section == 1) &#123; return 5; &#125; return 10;&#125;//控制页眉控件大小- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section &#123; if (section == 0) &#123; return CGSizeMake([UIScreen mainScreen].bounds.size.width, 20); &#125; return CGSizeMake(200, 10);&#125;//控制页脚控件大小- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section &#123; if (section == 0) &#123; return CGSizeMake([UIScreen mainScreen].bounds.size.width, 10); &#125; return CGSizeMake(10, 20);&#125; 自定义布局123456789101112131415161718192021222324//开始布局时候调用该方法执行准备工作- (void)prepareLayout;//控制指定区域内所有单元格的大小，位置等布局信息- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect;//控制指定NSIndexPath对应单元格的布局信息- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;//控制页眉页脚控件的布局信息- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;//控制指定分区的装饰控件的布局信息- (UICollectionViewLayoutAttributes *)layoutAttributesForDecorationViewOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath;#pragma mark - 重写显示、隐藏动画//当单元格动态增加时自动调用- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;//当单元格动态消失时自动调用- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;//当页眉页脚动态增加时自动调用- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath;//当页眉页脚动态消失时自动调用- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath;//当装饰控件动态增加时自动调用- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath;//当装饰控件动态增加时自动调用- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath; 环形布局示例控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;ViewController.h&quot;#import &quot;CircleLayout.h&quot;@interface ViewController ()&lt;UICollectionViewDelegate,UICollectionViewDataSource&gt;/* collectionView */@property (nonatomic, strong) UICollectionView *cView;/* cell count */@property (nonatomic, assign) NSInteger cellCount;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.navigationItem.title = @&quot;自定义布局&quot;; self.view.backgroundColor = [UIColor greenColor]; _cellCount = 16; [self.view addSubview:self.cView]; // Do any additional setup after loading the view, typically from a nib.&#125;- (UICollectionView *)cView &#123; if (!_cView) &#123; //流水布局 CircleLayout *layout = [CircleLayout new]; UICollectionView *cView = [[UICollectionView alloc] initWithFrame:CGRectMake(0, 74, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.width) collectionViewLayout:layout]; cView.backgroundColor = [UIColor orangeColor]; //设置代理 cView.delegate = self; cView.dataSource = self; //注册cell [cView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellID&quot;]; //添加手势识别 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapClick:)]; [cView addGestureRecognizer:tap]; _cView = cView; &#125; return _cView;&#125;- (void)tapClick:(UITapGestureRecognizer *)sender &#123; if (sender.state == UIGestureRecognizerStateEnded) &#123; //获取触碰点位置 CGPoint point = [sender locationInView:_cView]; //获取点击点所在单元格的NSIndexPath NSIndexPath *indexPath = [_cView indexPathForItemAtPoint:point]; //如果单元格存在 if (indexPath) &#123; _cellCount --; //删除点击的单元格 [_cView deleteItemsAtIndexPaths:@[indexPath]]; &#125;else&#123; _cellCount ++; //在UICollectionView开始处添加一个单元格 [_cView insertItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:0 inSection:0]]]; &#125; &#125;&#125;//设置每个分区多少Item- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section &#123; return _cellCount;&#125;//设置Item- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellID&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor blueColor]; return cell;&#125;//选中Item- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@&quot;分区：%ld,索引：%ld&quot;,indexPath.section,indexPath.item);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 自定义布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import &quot;CircleLayout.h&quot;#define ITEM_SIZE 72@interface CircleLayout ()/* center */@property (nonatomic, assign) CGPoint center;/* radius */@property (nonatomic, assign) CGFloat radius;/* cellCount */@property (nonatomic, assign) NSInteger cellCount;@end@implementation CircleLayout//开始布局时候调用该方法执行准备工作- (void)prepareLayout &#123; [super prepareLayout]; CGSize size = self.collectionView.frame.size; //计算需要包含多少个单元格 _cellCount = [self.collectionView numberOfItemsInSection:0]; //计算圆心 _center = CGPointMake(size.width/2.0, size.height/2.0); //计算半径（以宽高最小值的2.5分之一为半径） _radius = MIN(size.width, size.height)/2.5;&#125;//控制指定NSIndexPath对应单元格的布局信息- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath &#123; UICollectionViewLayoutAttributes *attr = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //设置单元格大小 attr.size = CGSizeMake(ITEM_SIZE, ITEM_SIZE); //设置单元格中心点坐标 attr.center = CGPointMake(_center.x+_radius*cosf(2*M_PI*indexPath.item/_cellCount), _center.y+_radius*sinf(2*M_PI*indexPath.item/_cellCount)); return attr;&#125;//控制指定区域内所有单元格的大小，位置等布局信息- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123; NSMutableArray *attrs = [NSMutableArray array]; //将控制每个单元格布局的UICollectionViewLayoutAttributes添加到数组中 for (NSInteger i = 0; i &lt; _cellCount; i ++) &#123; NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0]; [attrs addObject:[self layoutAttributesForItemAtIndexPath:index]]; &#125; return attrs;&#125;#pragma mark - 重写单元格显示、隐藏动画//当单元格动态增加时自动调用- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath &#123; UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath]; attr.alpha = 0.0; attr.center = CGPointMake(_center.x, _center.y); return attr;&#125;//当单元格动态消失时自动调用- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath *)itemIndexPath &#123; UICollectionViewLayoutAttributes *attr = [self layoutAttributesForItemAtIndexPath:itemIndexPath]; attr.alpha = 1.0; attr.center = CGPointMake(_center.x, _center.y); attr.transform3D = CATransform3DMakeScale(0.1, 0.1, 1.0); return attr;&#125;@end","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"NSPredicate筛选","date":"2017-08-04T02:53:05.000Z","path":"2017/08/04/NSPredicate筛选/","text":"NSPredicate,用于定义一个筛选条件，对集合进行筛选 占位符12%K 用于动态传入属性名%@ 用于动态设置属性值 表达式语法1234567=／== 相等&gt;=/=&gt; 大于等于&lt;=/=&lt; 小于等于&gt; 大于&lt; 小于!=/&lt;&gt; 不等于BETWEEN 区间(表达式 BETWEEN &#123;下限, 上限&#125;) 逻辑运算符123AND/&amp;&amp; 与OR/|| 或NOT/! 非 字符串比较运算符（默认区分大小写和重音符号，可再运算符后加c、d设置不区分，例：”ABCDEF BEGINSWITH[c] Abc”）12345BEGINSWITH 检查字符串是否以指定的子串开头ENDSWITH 检查字符串是否以指定的子串结尾CONTAINS 检查字符串是否包含指定子串LIKE 检查字符串是否匹配指定的字符串模版(允许使用*和？通配符，*表示任意多个字符，？表示一个字符)MATCHES 检查字符串是否匹配指定的正则表达式 操作集合的运算符12345678ANY/SOME 只要集合中一个元素满足条件就返回YESALL 必须集合中全部元素满足条件才返回YESNONE 必须集合中全部元素都不满足条件才返回YESIN 当左边表达式或值出现在右边集合中时返回YESarray[index] 返回数组index索引处元素array[FIRST] 返回数组第一个元素array[LAST] 返回数组最后一个元素array[SIZE] 返回数组元素个数 直接量123456789FALSE/NO 假TRUE/YES 真NULL/NIL 空SELF 对象自身&quot;text&quot;/&apos;text&apos; 表示字符串&#123;&apos;x&apos;,&apos;x&apos;,&apos;x&apos;&#125; 数组0x 十六进制0o 八进制0b 二进制 保留字1AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSPREDICATE","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Python定义类","date":"2017-06-12T06:19:05.000Z","path":"2017/06/12/Python定义类/","text":"定义类在Python中，类通过 class 关键字定义。以 Person 为例，定义一个Person类如下：1234class Person(object): pass #pass是空语句，是为了保持程序结构的完整性.pass 不做任何事情，一般用做占位语句。按照 Python 的编程习惯，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。 创建实例1person = Person() 由于Python是动态语言，对每一个实例，都可以直接给他们添加属性并赋值123456789101112131415161718class Super(object): passsubclassA = Super()subclassA.name = &quot;name&quot;print subclassAprint subclassA.name&gt;&gt;&lt;__main__.Super object at 0x10c022650&gt;namesubclassB = Super()subclassB.age = 17print subclassBprint subclassB.age&gt;&gt;&lt;__main__.Super object at 0x10c022890&gt;17 初始化实例属性123456789101112131415161718192021在定义 Person 类时，可以为Person类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用，我们就能在此为每个实例都统一加上以下属性：class Person(object): def __init__(self, name, gender, birth): self.name = name self.gender = gender self.birth = birth__init__() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。相应地，创建实例时，就必须要提供除 self 以外的参数：xiaoming = Person(&apos;Xiao Ming&apos;, &apos;Male&apos;, &apos;1991-1-1&apos;)xiaohong = Person(&apos;Xiao Hong&apos;, &apos;Female&apos;, &apos;1992-2-2&apos;)有了__init__()方法，每个Person实例在创建时，都会有 name、gender 和 birth 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符：print xiaoming.name# 输出 &apos;Xiao Ming&apos;print xiaohong.birth# 输出 &apos;1992-2-2&apos; python中访问限制123456789101112131415161718Python对属性权限的控制是通过属性名来实现的，如果一个属性由双下划线开头(__)，该属性就无法被外部访问。class Person(object): def __init__(self, name): self.name = name self._title = &apos;Mr&apos; self.__job = &apos;Student&apos;p = Person(&apos;Bob&apos;)print p.name# =&gt; Bobprint p._title# =&gt; Mrprint p.__job# =&gt; ErrorTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Person&apos; object has no attribute &apos;__job&apos;但是，如果一个属性以&quot;__xxx__&quot;的形式定义，那它又可以被外部访问了，以&quot;__xxx__&quot;定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常我们不要把普通属性用&quot;__xxx__&quot;定义。 创建类属性类是模板，而实例则是根据类创建的对象。绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份。123456789101112131415161718192021222324class Person(object): count = 0 def __init__(self,name): Person.count += 1 self.name = namep1 = Person(&apos;Bob&apos;)print Person.count&gt;&gt;1p2 = Person(&apos;Alice&apos;)print Person.count&gt;&gt;2p3 = Person(&apos;Tim&apos;)print Person.count&gt;&gt;3print Person.count #因为类属性是直接绑定在类上的，所以，访问类属性不需要创建实例，就可以直接访问&gt;&gt;3 当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问。 定义实例方法12345678910111213141516class Person(object): def __init__(self, name, score): self.__score = score def get_grade(self): if self.__score &gt;= 80: return &apos;A&apos; elif self.__score &gt;= 60: return &apos;B&apos; else: return &apos;C&apos;p1 = Person(&apos;Bob&apos;, 90)print p1.get_grade()&gt;&gt;A 我们在 class 中定义的实例方法其实也是属性，它实际上是一个函数对象把函数添加为属性1types.MethodType(f, p, Class) #参数(函数，实例，类) 定义类方法和属性类似，方法也分实例方法和类方法。1234567891011121314151617通过标记一个 @classmethod，该方法将绑定到 Person 类上class Person(object): __count = 0 @classmethod def how_many(cls): return cls.__count def __init__(self,name): self.name = name Person.__count += 1print Person.how_many()&gt;&gt;0p1 = Person(&apos;Bob&apos;)print Person.how_many()&gt;&gt;1 注意：因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。 继承12345678class Person(object): #父类 def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): #子类 def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) #初始化父类 self.score = score #初始化子类属性 多继承12345678910111213141516171819class A(object): def __init__(self, a): print &apos;init A...&apos; self.a = aclass B(A): def __init__(self, a): super(B, self).__init__(a) print &apos;init B...&apos;class C(A): def __init__(self, a): super(C, self).__init__(a) print &apos;init C...&apos;class D(B, C): def __init__(self, a): super(D, self).__init__(a) print &apos;init D...&apos; 判断类型函数isinstance()可以判断一个变量的类型，既可以用在Python内置的数据类型如str、list、dict，也可以用在我们自定义的类，它们本质上都是数据类型。1234567891011121314151617181920212223242526272829303132class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = scoreclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = courset = Teacher(&apos;Alice&apos;, &apos;Female&apos;, &apos;English&apos;)print isinstance(t,Person)&gt;&gt;Trueprint isinstance(t,Student)&gt;&gt;Falseprint isinstance(t,Teacher)&gt;&gt;Trueprint isinstance(t,object)&gt;&gt;True 多态123456789101112131415161718192021222324252627282930313233343536class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def whoAmI(self): return &apos;I am a Person, my name is %s&apos; % self.nameclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return &apos;I am a Student, my name is %s&apos; % self.nameclass Teacher(Person): def __init__(self, name, gender, course): super(Teacher, self).__init__(name, gender) self.course = course def whoAmI(self): return &apos;I am a Teacher, my name is %s&apos; % self.namedef who_am_i(x): print x.whoAmI()p = Person(&apos;Tim&apos;, &apos;Male&apos;)s = Student(&apos;Bob&apos;, &apos;Male&apos;, 88)t = Teacher(&apos;Alice&apos;, &apos;Female&apos;, &apos;English&apos;)who_am_i(p)who_am_i(s)who_am_i(t)运行结果：I am a Person, my name is TimI am a Student, my name is BobI am a Teacher, my name is Alice 获取对象信息1234567891011121314151617181920212223242526例如，已有定义：class Person(object): def __init__(self, name, gender): self.name = name self.gender = genderclass Student(Person): def __init__(self, name, gender, score): super(Student, self).__init__(name, gender) self.score = score def whoAmI(self): return &apos;I am a Student, my name is %s&apos; % self.name首先可以用 type() 函数获取变量的类型，它返回一个 Type 对象：&gt;&gt;&gt;print type(123)&lt;type &apos;int&apos;&gt;&gt;&gt;&gt; s = Student(&apos;Bob&apos;, &apos;Male&apos;, 88)&gt;&gt;&gt;print type(s)&lt;class &apos;__main__.Student&apos;&gt;其次，可以用 dir() 函数获取变量的所有属性：&gt;&gt;&gt;print dir(123) # 整数也有很多属性...[&apos;__abs__&apos;, &apos;__add__&apos;, &apos;__and__&apos;, &apos;__class__&apos;, &apos;__cmp__&apos;, ...]&gt;&gt;&gt;print dir(s)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;gender&apos;, &apos;name&apos;, &apos;score&apos;, &apos;whoAmI&apos;]&gt;&gt;&gt; print filter(lambda x:x[0:2] != &apos;__&apos;,dir(s))[&apos;gender&apos;, &apos;name&apos;, &apos;score&apos;, &apos;whoAmI&apos;] 特殊方法特殊方法是定义在类中的，不需要手动调用，python的某些函数和操作符会自动去调用对应的特殊方法。我们只需要编写需要的特殊方法，但是有关联性的特殊方法要同时实现1.要把一个类的实例变成 str1234567891011121314 Python 定义了__str__()和__repr__()两种方法，__str__()用于显示给用户，而__repr__()用于显示给开发人员。class Person(object): def __init__(self, name, gender): self.name = name self.gender = gender def __str__(self): return &apos;(Person: %s, %s)&apos; % (self.name, self.gender) __repr__ = __str__ #偷懒的定义__repr__的方法&gt;&gt;&gt; p = Person(&apos;Bob&apos;, &apos;male&apos;)&gt;&gt;&gt; print p(Person: Bob, male)&gt;&gt;&gt; p&lt;main.Person object at 0x10c941890&gt; 2.排序(对类进行自定义排序规则)123456789101112131415161718class Student(object): def __init__(self, name, score): self.name = name self.score = score def __str__(self): return &apos;(%s: %s)&apos; % (self.name, self.score) __repr__ = __str__ def __cmp__(self, s): if self.name &lt; s.name: return -1 elif self.name &gt; s.name: return 1 else: return 0L = [Student(&apos;Tim&apos;, 99), Student(&apos;Bob&apos;, 88), Student(&apos;Alice&apos;, 77)]print sorted(L)&gt;&gt;[(Alice: 77), (Bob: 88), (Tim: 99)] 3.长度123456789class Students(object): def __init__(self, *args): self.names = args def __len__(self): return len(self.names)ss = Students(&apos;Bob&apos;, &apos;Alice&apos;, &apos;Tim&apos;)print len(ss)&gt;&gt;3 4.数学运算1234567891011121314151617181920212223242526272829303132333435363738394041424344class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __add__(self, r): #加 return Rational(self.p * r.q + self.q * r.p, self.q * r.q) def __sub__(self, r): #减 return Rational(self.p*r.q-self.q*r.p,self.q*r.q) def __mul__(self, r): #乘 return Rational(self.p*r.p,self.q*r.q) def __div__(self, r): #除 return Rational(self.p*r.q,self.q*r.p) def __str__(self): if self.p &lt; self.q: k = self.p else: k = self.q for x in range(1,k+1): if self.p%x==0 and self.q%x == 0: self.p = self.p / x self.q = self.q / x return &apos;%s/%s&apos; % (self.p, self.q) __repr__ = __str__ __repr__ = __str__r1 = Rational(1, 2)r2 = Rational(1, 4)print r1 + r2print r1 - r2print r1 * r2print r1 / r2&gt;&gt;3/41/41/82/1 5.数据类型转换12345678910111213class Rational(object): def __init__(self, p, q): self.p = p self.q = q def __int__(self): return self.p // self.q def __float__(self): return float(self.p) / self.qprint float(Rational(7, 2))print float(Rational(1, 3)) 6.property1234567891011121314151617181920212223242526272829303132333435363738如果没有定义set方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。给Student类加一个grade属性，根据 score 计算 A（&gt;=80）、B、C（&lt;60）。class Student(object): def __init__(self, name, score): self.name = name self.__score = score @property def score(self): return self.__score @score.setter def score(self, score): if score &lt; 0 or score &gt; 100: raise ValueError(&apos;invalid score&apos;) self.__score = score @property def grade(self): if self.__score &gt;= 80: return &apos;A&apos; elif self.__score &gt;= 60: return &apos;B&apos; else: return &apos;C&apos;s = Student(&apos;Bob&apos;, 59)print s.grades.score = 60print s.grades.score = 99print s.grade&gt;&gt;CBA 7.限制属性的添加1234567__slots__是指一个类允许的属性列表,__slots__的目的是限制当前类所能拥有的属性，如果不需要添加任意动态的属性，使用__slots__也能节省内存。class Student(object): __slots__ = (&apos;name&apos;, &apos;gender&apos;, &apos;score&apos;) def __init__(self, name, gender, score): self.name = name self.gender = gender self.score = score 8。类实例变为可调用对象123456789101112一个类实例要变成一个可调用对象，只需要实现一个特殊方法__call__()。class Fib(object): #斐波那契数列 def __call__(self,num): a,b,L=0,1,[] for n in range(num): L.append(a) a,b=b,a+b return L f = Fib()print f(10)&gt;&gt;[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)进阶二","date":"2017-06-12T05:42:19.000Z","path":"2017/06/12/Python进阶二/","text":"模块导入要使用一个模块，我们必须首先导入该模块。Python使用import语句导入一个模块。12345678例如，导入系统自带的模块 math：import math你可以认为math就是一个指向已导入模块的变量，通过该变量，我们可以访问math模块中所定义的所有公开的函数、变量和类：&gt;&gt;&gt; math.pow(2, 0.5) # pow是函数1.4142135623730951&gt;&gt;&gt; math.pi # pi是变量3.141592653589793 如果我们只希望导入用到的math模块的某几个函数，而不是所有函数，可以用下面的语句：123456from math import pow, sin, log这样，可以直接引用 pow, sin, log 这3个函数，但math的其他函数没有导入进来：&gt;&gt;&gt; pow(2, 10)1024.0&gt;&gt;&gt; sin(3.14)0.0015926529164868282 如果遇到名字冲突怎么办？比如math模块有一个log函数，logging模块也有一个log函数，如果同时使用，如何解决名字冲突？123456789101112如果使用import导入模块名，由于必须通过模块名引用函数名，因此不存在冲突：import math, loggingprint math.log(10) # 调用的是math的log函数logging.log(10, &apos;something&apos;) # 调用的是logging的log函数如果使用 from...import 导入 log 函数，势必引起冲突。这时，可以给函数起个“别名”来避免冲突：from math import logfrom logging import log as logger # logging的log现在变成了loggerprint log(10) # 调用的是math的loglogger(10, &apos;import from logging&apos;) # 调用的是logging的log 动态导入模块如果导入的模块不存在，Python解释器会报 ImportError 错误：有的时候，两个不同的模块提供了相同的功能，比如 StringIO 和 cStringIO 都提供了StringIO这个功能。这是因为Python是动态语言，解释执行，因此Python代码运行速度慢。如果要提高Python代码的运行速度，最简单的方法是把某些关键函数用 C 语言重写，这样就能大大提高执行速度。同样的功能，StringIO 是纯Python代码编写的，而 cStringIO 部分函数是 C 写的，因此 cStringIO 运行速度更快。利用ImportError错误，我们经常在Python中动态导入模块：1234567try: from cStringIO import StringIOexcept ImportError: from StringIO import StringIO上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。try 的作用是捕获错误，并在捕获到指定错误时执行 except 语句。 利用import … as …，还可以动态导入不同名称的模块。 添加第三方模块pip install12pip install web.py #添加web模块查找第三方模块：https://pypi.python.org/ 12345678910111213141516__future__Python的新版本会引入新的功能，但是，实际上这些功能在上一个老版本中就已经存在了。要“试用”某一新的特性，就可以通过导入__future__模块的某些功能来实现。例如，Python 2.7的整数除法运算结果仍是整数：&gt;&gt;&gt; 10 / 33但是，Python 3.x已经改进了整数的除法运算，“/”除将得到浮点数，“//”除才仍是整数：&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33要在Python 2.7中引入3.x的除法规则，导入__future__的division：&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; print 10 / 33.3333333333333335","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)进阶","date":"2017-06-07T08:29:14.000Z","path":"2017/06/07/Python进阶/","text":"python函数可以把函数作为参数12345&gt;&gt;&gt; def add(x, y, f):... return f(x)+f(y)...&gt;&gt;&gt; add(-5, 9, abs)14 函数返回值可以为函数12345678&gt;&gt;&gt; def f():... def g(x):... return x*x... return g...&gt;&gt;&gt; fn = f()&gt;&gt;&gt; print fn(3)9 闭包内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数的情况，称为闭包（Closure）。闭包的特点是返回的函数还引用了外层函数的局部变量，所以，要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。123456789101112131415161718192021222324252627&gt;&gt;&gt; # 希望一次返回3个函数，分别计算1x1,2x2,3x3:... def count():... fs = []... for i in range(1, 4):... def f(i):... return i*i... fs.append(f)... return fs...&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; print f1(),f2(),f3()9 9 9&gt;&gt;&gt; # 希望一次返回3个函数，分别计算1x1,2x2,3x3:... def count():... fs = []... for i in range(1, 4):... def f(n = i):... return n*n... fs.append(f)... return fs...&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; print f1(),f2(),f3()1 4 9对比上面两个函数可知：python函数定义时仅走声明部分，只有当真正调用函数时才会走函数的实现部分 匿名函数关键字lambda 表示匿名函数，冒号前面的表示函数参数，后面表达式为结果。匿名函数有个限制，就是只能有一个表达式，不写return，返回值就是该表达式的结果。使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码12345&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81]可以看出，匿名函数 lambda x: x * x 实际上就是：def f(x): return x * x 装饰器(decorator)Python的 decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后，返回一个新函数。12345678910111213141516171819202122232425262728293031323334353637383940无参decoratordef fn(f): def s(x): r = f(x) print &apos;!&apos; return r return s@fndef g(x): return xprint g(5)&gt;&gt;!5有参无参有参无参decoratorimport timedef performance(unit): def returnfunction(f): def decoratorfuntion(*args,**kw): t1 = time.time() # *args,**kw可传入任意数量参数 r = f(*args,**kw) t2 = time.time() t = t2-t1 if unit == &apos;ms&apos;: t = t*1000 print &apos;call %s() in %f%s&apos;%(f.__name__,t,unit) return r return decoratorfuntion return returnfunction@performance(&apos;ms&apos;)def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10)&gt;&gt;call factorial() in 14.061928ms3628800 12345678910111213141516171819202122232425262728293031323334353637383940414243444546完善decorator有decorator的情况下，打印函数名：def log(f): def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) return wrapper@logdef f2(x): passprint f2.__name__&gt;&gt;wrapper可见，由于decorator返回的新函数函数名已经不是&apos;f2&apos;，而是@log内部定义的&apos;wrapper&apos;。这对于那些依赖函数名的代码就会失效.这对于那些依赖函数名的代码就会失效。decorator还改变了函数的__doc__等其它属性。如果要让调用者看不出一个函数经过了@decorator的“改造”，就需要把原函数的一些属性复制到新函数中：def log(f): def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) wrapper.__name__ = f.__name__ wrapper.__doc__ = f.__doc__ return wrapper这样写decorator很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的functools可以用来自动化完成这个“复制”的任务：import functoolsdef log(f): @functools.wraps(f) def wrapper(*args, **kw): print &apos;call...&apos; return f(*args, **kw) return wrapper最后需要指出，由于我们把原函数签名改成了(*args, **kw)，因此，无法获得原函数的原始参数信息。即便我们采用固定参数来装饰只有一个参数的函数：def log(f): @functools.wraps(f) def wrapper(x): print &apos;call...&apos; return f(x) return wrapper也可能改变原函数的参数名，因为新函数的参数名始终是 &apos;x&apos;，原函数定义的参数名不一定叫 &apos;x&apos;。@functools.wraps(f)加在def wrapper(*args, **kw):前面 Python内置高阶函数1.map():接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。123456假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：&gt;&gt;&gt; def format_name(s):... return s[0].upper()+s[1:].lower()...&gt;&gt;&gt; print map(format_name, [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;])[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 2.reduce():接收一个函数 f (f 必须接收两个参数)，一个list,还可以接收第3个可选参数，作为计算的初始值。reduce()对list的每个元素反复调用函数f，并返回最终结果值。1234567&gt;&gt;&gt; def f(x,y):... return x*y...&gt;&gt;&gt; print reduce(f,[1,2,3])6&gt;&gt;&gt; print reduce(f,[1,2,3],2)12 3.filter():接收一个函数 f 和一个list,这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。123456例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：&gt;&gt;&gt; def f(x):... return x%2 == 1...&gt;&gt;&gt; filter(f,[1,2,3,4,5,6,7,8])[1, 3, 5, 7] 4.sorted():接收一个list和一个函数 f ,以f的排序规则返回一个重新排序的list，默认f为从小到大排序。比较函数f的定义是，传入两个待比较的元素 x, y.如果 x 应该排在 y 的前面，返回 -1，如果 x 应该排在 y 的后面，返回 1。如果 x 和 y 相等，返回 0。123456789101112&gt;&gt;&gt; def f(x,y):... if x &gt; y:... return -1... elif x &lt; y:... return 1... else:... return 0...&gt;&gt;&gt; sorted([1,5,3,8,10],f)[10, 8, 5, 3, 1]&gt;&gt;&gt; sorted([1,5,3,8,10])[1, 3, 5, 8, 10]5.functools.partial偏函数可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定默认值，这样，新函数调用的难度就降低了。偏函数第一个参数为函数f，后面的参数为f的参数的赋值表达式。注意：使用偏函数必须保证偏函数至少有一个必须赋值的参数123456789101112import functoolsdef f(x,y,z): return x,y,zg = functools.partial(f,y = 1,z = 1)print f(1,2,3)&gt;&gt;(1, 2, 3)print g(1)&gt;&gt;(1, 1, 1)","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)基础二","date":"2017-06-07T04:05:23.000Z","path":"2017/06/07/Python基础二/","text":"迭代Python中，迭代永远是取出元素本身，而非元素的索引。1.对于有序集合，元素确实是有索引的。我们使用 enumerate() 函数可以取到索引；1234567891011121314151617181920212223&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul实际上，enumerate() 函数把：[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]变成了类似：[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)]因此，迭代的每一个元素实际上是一个tuple：for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：for index, name in enumerate(L): print index, &apos;-&apos;, name这样不但代码更简单，而且还少了两条赋值语句。可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 2.迭代dict的value123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.values()[85, 95, 59] 3.迭代dict的key和value1234567&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 生成list12345678请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100] print [x*(x+1) for x in range(1,101,2)] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]多层表达式利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。print [x*100+y*10+z for x in range(1,10) for y in range(0,10) for z in range(1,10) if x == z]","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"Python(2.7.10)基础","date":"2017-06-07T01:03:35.000Z","path":"2017/06/07/python基础/","text":"Python注意事项：1.Python区分大小写，2.Python代码有缩进规则.具有相同缩进的代码被视为代码块.Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。3.注释用”#”4.变量名：大小写英文，数字，下划线，数字不能开头 Python数据类型1.布尔值：Ture、False2.逻辑运算符：and(与)、or(或)、not(非)3.空：None4.list12345678list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据L = [0,&apos;aaaa&apos;,True]索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。因此，要打印第一个，用 L[0]:&gt;&gt;&gt; print L[0]我们可以用 -1 这个索引来表示最后一个元素，类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示&gt;&gt;&gt; print L[-1] 123456添加新元素第一个办法是用 list 的 append() 方法，把新元素追加到 list 的末尾另一个方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素删除元素如果元素排在最后一个，我们可以用list的pop()方法删除，若不是最后一个，可在（）内传入索引值来删除Python中替换元素,通过索引值直接赋值替换 5.tuple12345tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。t = (0,&apos;aaaa&apos;,False)因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义t = (1,)tuple是不可变的，但是，如果tuple里面有list元素，那么list元素可以改变。所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向&apos;a&apos;，就不能改成指向&apos;b&apos;，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 1234567891011121314151617对list和tuple进行切片L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：&gt;&gt;&gt; L[:3]只用一个 : ，表示从头到尾：&gt;&gt;&gt; L[:]因此，L[:]实际上复制出了一个新list或tuple切片操作还可以指定第三个参数：&gt;&gt;&gt; L[::2]第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片L[-2:]L[:-2]L[-4:-1:2]字符串 &apos;xxx&apos;和 Unicode字符串 u&apos;xxx&apos;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 6.dict1234567891011121314151617181920用 dict 表示“名字”-“成绩”的查找表如下：d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。花括号 &#123;&#125; 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。访问dict，可以简单地使用 d[key] 的形式来查找对应的 value注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。要避免 KeyError 发生，有两个办法：一是先判断一下 key 是否存在，用 in 操作符：if &apos;Paul&apos; in d: print d[&apos;Paul&apos;]如果 &apos;Paul&apos; 不存在，if语句判断为False，自然不会执行 print d[&apos;Paul&apos;] ，从而避免了错误。二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None dict中作为key的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。12345更新dict用赋值语句：&gt;&gt;&gt; d[&apos;Paul&apos;] = 72如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value遍历dict，直接使用for循环可以遍历 dict 的 key：由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 7.setset内部存储的元素是无序的,set会自动去掉重复的元素12345678910创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])访问 set中的某个元素实际上就是判断一个元素是否在set中。我们可以用 in 操作符判断：Bart是该班的同学吗？&gt;&gt;&gt; &apos;Bart&apos; in sTrueBill是该班的同学吗？&gt;&gt;&gt; &apos;Bill&apos; in sFalse set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。12345由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。直接使用 for 循环可以遍历 set 的元素：添加元素时，用set的add()方法：如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了删除set中的元素时，用set的remove()方法：如果删除的元素不存在set中，remove()会报错如果删除的元素不存在set中，remove()会报错 if、for、while循环过程中，可以用break退出当前循环，还可以用continue跳过本次循环后续代码，继续下一次循环。1234567891011&gt;&gt;&gt; a = 5&gt;&gt;&gt; if a &gt;= 3:... print &apos;yes&apos;... print a... elif a &gt;= 6:... print &apos;&gt;=6&apos;... else:... print &apos;&lt;3&apos;...yes5 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y 12345N = 10x = 0while x &lt; N: print x x = x + 1 函数在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。12345678910111213def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s,n函数可以有默认参数，可以返回多个值在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：def fn(*args): print args可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 printprint可以通过”,”或”+”一次输出多个值，区别在于：“,”作间隔输出时不同值之间会有一个空格出现，可以输出不同的数据类型“+”作间隔输出时不同值会连在一起，只能输出同数据类型12345678910111213&gt;&gt;&gt; print &quot;python&quot;,&quot;print&quot;python print&gt;&gt;&gt; print &quot;python&quot;+&quot;print&quot;pythonprint&gt;&gt;&gt; print &quot;python&quot;,3python 3&gt;&gt;&gt; print &quot;python&quot;+3Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot concatenate &apos;str&apos; and &apos;int&apos; objects r’…’和r’’’…’’’如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。r’…’输出单行字符串,如果要表示多行字符串，可以用’’’…’’’表示12345678910&gt;&gt;&gt; print &quot;\\\\\\\\&quot;\\\\&gt;&gt;&gt; print r&quot;\\\\\\\\&quot;\\\\\\\\&gt;&gt;&gt; print r&apos;&apos;&apos;\\\\\\\\... qqqqq... aaaa&apos;&apos;&apos;\\\\\\\\qqqqqaaaa 早期python不支持中文字符串编码，可以用u’…’和u’’’…’’’输出单行和多行 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释1# -*- coding: utf-8 -*-","tags":[{"name":"Python","slug":"Python","permalink":"https://Misaka-NO10032.github.io/tags/Python/"}]},{"title":"多线程","date":"2017-05-17T06:34:41.000Z","path":"2017/05/17/多线程/","text":"NSThread一个NSThread对象就代表一条线程123456789101112131415NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start];// 线程一启动，就会在线程thread中执行self的run方法主线程相关用法+ (NSThread *)mainThread; // 获得主线程- (BOOL)isMainThread; // 是否为主线程+ (BOOL)isMainThread; // 是否为主线程获得当前线程NSThread *current = [NSThread currentThread];线程的名字- (void)setName:(NSString *)n;- (NSString *)name; 其他创建线程方式1234567创建线程后自动启动线程[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];隐式创建并启动线程[self performSelectorInBackground:@selector(run) withObject:nil];上述2种创建线程方式的优缺点优点：简单快捷缺点：无法对线程进行更详细的设置 控制线程状态1234567891011121314启动线程- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态阻塞（暂停）线程+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态强制停止线程+ (void)exit;// 进入死亡状态注意：一旦线程停止（死亡）了，就不能再次开启任务 线程间通信12- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; NSOperation配合使用NSOperation和NSOperationQueue也能实现多线程编程,具体方式：先将需要执行的操作封装到一个NSOperation对象中然后将NSOperation对象添加到NSOperationQueue中系统会自动将NSOperationQueue中的NSOperation取出来将取出的NSOperation封装的操作放到一条新线程中执行 NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种NSInvocationOperation12345678创建NSInvocationOperation对象- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法注意:默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作,只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 NSBlockOperation1234567创建NSBlockOperation对象+ (id)blockOperationWithBlock:(void (^)(void))block;通过addExecutionBlock:方法添加更多的操作- (void)addExecutionBlock:(void (^)(void))block;注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 自定义子类继承NSOperation，实现内部相应的方法123456自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 NSOperationQueue的作用NSOperation可以调用start方法来执行任务，但默认是同步执行的如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作123添加操作到NSOperationQueue中- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; 最大并发数的相关方法(并发数:同时执行的任务数)12- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 队列的取消、暂停、恢复1234567取消队列的所有操作- (void)cancelAllOperations;也可以调用NSOperation的- (void)cancel方法取消单个操作暂停和恢复队列- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖NSOperation之间可以设置依赖来保证执行顺序,但不能相互依赖12比如一定要让操作A执行完后，才能执行操作B，可以这么写[operationB addDependency:operationA]; // 操作B依赖于操作A 操作的监听123可以监听一个操作的执行完毕- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"自定义控制器","date":"2017-05-16T08:57:42.000Z","path":"2017/05/16/自定义控制器/","text":"如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系 自定义控制器（带转场动画）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;#import &quot;XMGOneViewController.h&quot;#import &quot;XMGTwoViewController.h&quot;#import &quot;XMGThreeViewController.h&quot;@interface ViewController ()/** 正在显示的控制器 */@property (nonatomic, weak) UIViewController *showingVc;@end@implementation ViewController/** 如果2个控制器的view是父子关系(不管是直接还是间接的父子关系)，那么这2个控制器也应该为父子关系[a.view addSubview:b.view];[a addChildViewController:b];或者[a.view addSubview:otherView];[otherView addSubbiew.b.view];[a addChildViewController:b]; */- (void)viewDidLoad &#123; [super viewDidLoad]; // 通过addChildViewController添加的控制器都会存在于childViewControllers数组中 [self addChildViewController:[[XMGOneViewController alloc] init]]; [self addChildViewController:[[XMGTwoViewController alloc] init]]; [self addChildViewController:[[XMGThreeViewController alloc] init]];&#125;- (IBAction)buttonClick:(UIButton *)button &#123; // 移除其他控制器的view [self.showingVc.view removeFromSuperview]; // 获得控制器的位置（索引） NSUInteger index = [button.superview.subviews indexOfObject:button]; // 当前控制器的索引 NSUInteger oldIndex = [self.childViewControllers indexOfObject:self.showingVc]; // 添加控制器的view self.showingVc = self.childViewControllers[index]; self.showingVc.view.frame = self.contentView.bounds; [self.contentView addSubview:self.showingVc.view]; // 动画 CATransition *animation = [CATransition animation]; animation.type = @&quot;cube&quot;; animation.subtype = index &gt; oldIndex ? kCATransitionFromRight : kCATransitionFromLeft; animation.duration = 0.5; [self.contentView.layer addAnimation:animation forKey:nil];&#125;/** * 屏幕即将旋转到某个方向时会调用这个方法 */- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration&#123; NSLog(@&quot;%@ willRotateToInterfaceOrientation&quot;, self.class);&#125;@end 级联菜单型的控制器（类似多个相关滚轮选择）的实现：在容器里添加多个子控制器，然后在子控制器之间可以通过代理传递关联关系也可以选择使用多个tableView实现","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"ScrollView中控件悬停和拉伸图片","date":"2017-05-16T08:33:55.000Z","path":"2017/05/16/ScrollView中控件悬停和拉伸图片/","text":"实际开发中有时会需要用到随着拖动视图上部的image会出现拉伸效果，而下面的控件位置不动的情况。可通过监听scrollView滚动来实现123456789101112131415161718192021222324#pragma mark - &lt;UIScrollViewDelegate&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat imageH = self.imageView.frame.size.height; CGFloat offsetY = scrollView.contentOffset.y; NSLog(@&quot;%f&quot;,scrollView.contentOffset.y); if (offsetY &gt;= imageH) &#123; // 将静止的控件添加到控制器的view中，设置Y值为0 CGRect staticF = self.redView.frame; staticF.origin.y = 0; self.staticView.frame = staticF; [self.view addSubview:self.staticView]; &#125; else &#123; // 将红色控件添加到scrollView中，设置Y值为图片的高度 CGRect staticF = self.staticView.frame; staticF.origin.y = 140; self.staticView.frame = staticF; [self.scrollView addSubview:self.staticView]; &#125; CGFloat scale = 1 - (offsetY / 70); scale = (scale &gt;= 1) ? scale : 1; //图片拉伸 self.imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"CodeSnippets","date":"2017-03-27T06:25:22.000Z","path":"2017/03/27/CodeSnippets/","text":"利用Code Snippets可以提高工作效率，而且Code Snippets可以在不同设备之间移动。Xcode中的Code Snippets默认放在下面的目录中：~/Library/Developer/Xcode/UserData/CodeSnippets 定义自己的Code Snippets1.先写好代码片段，占位符的生成语法：&lt;#占位符#&gt;2.将代码片段拖入Xcode右侧代码片段区3.编辑好代码片段信息4.使用（可以通过拖拽和快捷方式使用）","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"masonry","date":"2017-03-27T03:48:28.000Z","path":"2017/03/27/masonry/","text":"把masonry框架载入工程后，请把以下两句宏定义写到头文件内，以便省略该框架语句的“mas_”前缀1234#define MAS_SHORTHAND#define MAS_SHORTHAND_GLOBALS//两句宏一定要在import前面#import &lt;Masonry.h&gt; 约束关系123.equalTo : = (对应NSLayoutRelationEqual) .lessThanOrEqualTo : &lt;= (对应NSLayoutRelationLessThanOrEqual) .greaterThanOrEqualTo : &gt;= (对应NSLayoutRelationGreaterThanOrEqual) 基本设置属性1234561.尺寸：width、height、size2.边界：left、leading、right、trailing、top、bottom3.中心点：center、centerX、centerY4.边界：edges5.偏移量：offset、insets、sizeOffset、centerOffset6.priority()约束优先级（0~1000），multipler乘因数, dividedBy除因数 使用方法1.makeConstraints(添加约束)1234567[redView makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(10); //直接在equalTo()内填写数字，默认为相对于父视图而言，等同于下面注释的语句 //make.left.equalTo(self.view.left).offset(10); //offset()内填写偏差量 make.top.equalTo(50); make.width.equalTo(self.view).dividedBy(2).offset(-15);//dividedBy()，除以某个量，用以实现按比例设置约束；multipliedBy()则是乘以某个量 make.height.equalTo(self.view).dividedBy(5); &#125;];2.updateConstraints(更新约束、亦可添加新约束)注意：当更新一个控件的约束的时候，与本控件相关的控件的约束也会随之改变123[redView updateConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(20); &#125;];3.remakeConstraints(重置之前的约束)1234[yellowView remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.width.equalTo(blueView); make.top.equalTo(blueView.bottom).offset(10); &#125;]; AutoLayout关于更新的几个方法的区别： setNeedsLayout：告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用layoutSubviews。 layoutIfNeeded：告知页面布局立刻更新。所以一般都会和setNeedsLayout一起使用。如果希望立刻生成新的frame需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。 layoutSubviews：系统重写布局 setNeedsUpdateConstraints：告知需要更新约束，但是不会立刻开始 updateConstraintsIfNeeded：告知立刻更新约束 updateConstraints：系统更新约束","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS简单动画","date":"2017-03-20T02:47:09.000Z","path":"2017/03/20/iOS动画/","text":"三种简单动画 首尾动画简单介绍首尾式动画效果（1）开始动画（2）设置动画相关的时间等（3）参与动画的行动（4）提交动画1234567891011[UIView beginAnimations:nil context:nil];//beginAnimations表示此后的代码要“参与到”动画中[UIView setAnimationDuration:2.0];self.headImageView.bounds = rect;// self.headImageView.alpha = 0; ...... setAnimationDuration用来指定动画持续时间[UIView commitAnimations];commitAnimations,将beginAnimation之后的所有动画提交并生成动画 block动画12345[UIView animateWithDuration:0.4 animations:^&#123; //添加动画 &#125; completion:^(BOOL finished) &#123; //动画结束后执行的操作 &#125;]; 序列帧动画12345678//设置动画数组[self.tom setAnimationImages:arrayM];//设置动画播放次数[self.tom setAnimationRepeatCount:1];//设置动画播放时间[self.tom setAnimationDuration:40*0.075];//开始动画[self.tom startAnimating];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Quartz2D","date":"2017-03-20T01:42:33.000Z","path":"2017/03/20/Quartz2D/","text":"Quartz2D(二维绘图引擎),用途：绘制图形、绘制文字、绘制和生成图片（图像）、读取和生成PDF、截图和裁剪图片、自定义UI控件…Quartz2D提供以下几种类型的Graphics Context：Bitmap Graphics ContextPDF Graphics ContextWindow Graphics ContextLayer Graphics ContextPrinter Graphics Context 例：使用Quartz2D自定义view12341.新建一个view，继承自UIView2.实现-(void)drawRect:(CGRect)rect方法，然后在这个方法中先取到跟当前view相关联的图形上下文，然后绘制相应的图形内容，再利用图形上下文将绘制的所有内容渲染显示到view上面注意：-(void)drawrect:(CGRect)rect方法会在view要显示的时候调用，在viewDidLoad,viewWillAppear方法后，viewDidAppear方法前调用;在每次刷新界面时调用，手动调用无效；若要调用该方法，需使用setNeedsDisplay（重绘，全屏）或setNeedsDisplayInRect:(重绘，指定区域)方法。方法一：最根本的方法，其他是在本方法上的简化123456789101112131415161718-(void)drawrect:(CGRect)rect &#123;//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径CGMutablePathRef path = CGPathCreatMutable();//设置起点CGPathMoveToPoint(path,NULL,50,50);(路径，形变，x，y)添加一条线的另一个点CGPathAddLineToPoint(path,NULL,100,100); //3.把路径添加到上下文CGContextAddPath(ctx,path);//4.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法二：对方法一的简化1234567891011121314-(void)drawrect:(CGRect)rect &#123;//rect是控件的bounds//1.获取图形上下文(ref表示引用)CGContextRef ctx = UIGraphicsGetCurrentContext(); //2.绘制路径//创建路径//设置起点CGContextMoveToPoint(ctx,50,50);添加一条线的另一个点CGContextAddLineToPoint(ctx,100,100);//3.渲染上下文CGContextStrokePath(ctx);//描边绘制路径&#125;方法三：贝瑟尔路径（UIKit对Quartz2D的封装）1234567891011-(void)drawrect:(CGRect)rect &#123;//贝瑟尔路径//创建路径UIBezierPath *path = [UIBezierPath bezierPath];//设置起点[path moveToPoint:CGPointMake(50,50)];//设置另一点[path addLineToPoint:CGPointMake(100,100)];//绘制路径[path stroke];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"RunLoop","date":"2017-03-16T01:29:41.000Z","path":"2017/03/16/RunLoop/","text":"一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出这种模型通常被称作 Event Loop(事件循环)。RunLoop是iOS中的Event Loop。Runloop下面有多种模式(Mode)，但是同一时间下只有一种模式可以运行，处理当前模式下事件。Cocoa中的预定义模式有: Default模式：NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation)，默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式。 Connection模式：NSConnectionReplyMode(Cocoa)，处理NSConnection对象相关事件，系统内部使用，用户基本不会使用。 Modal模式：NSModalPanelRunLoopMode(Cocoa)，处理modal panels事件。 Event tracking模式：UITrackingRunLoopMode(iOS) NSEventTrackingRunLoopMode(cocoa)，描述：在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。 Common模式：NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation)，这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes.可使用CFRunLoopAddCommonMode方法想Common Modes中添加自定义modes。 Mode下包含Source（事件源）、Observer（观察者：监听runloop的状态改变）、Timer（定时器） RunLoop内部逻辑","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"文件下载","date":"2017-03-15T02:36:16.000Z","path":"2017/03/15/文件下载/","text":"HEAD请求：请求头信息，并不返回请求数据体，而只返回请求头信息，常用用于在文件下载中取得文件大小、类型等信息。1234NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:0 timeoutInterval:2.0f];//HEAD头(返回文件资源的信息，不返回具体数据)//如果要获取资源的MIMEType，也必须用HEAD，否则，数据会重复下载两次request.HTTPMethod = @&quot;HEAD&quot;;针对文件的分段下载，要先通过HEAD请求获取到文件的信息，让后才能分段下载123456789101112可以通过Range指定每次从网路下载的数据包的大小示例：bytes = 0-499 从0到499的头500个字节bytes = 500-999 从500到999的第二个500字节bytes = 500- 从500字节以后的所有字节bytes = -500 最后500个字节bytes = 500-599,800-899 同时指定几个范围NSString *range = [NSString stringWithFormat:@&quot;Bytes=%lld-%lld&quot;,0,499];NSMutableURLRequest *request= [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:5.0f]; //通过请求头设置数据请求范围.要对请求进行操作,肯定要对请求头做操作! [request setValue:range forHTTPHeaderField:@&quot;Range&quot;];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"手势识别","date":"2017-03-14T07:18:16.000Z","path":"2017/03/14/手势识别/","text":"iOS开发中基本手势有六种：点击手势（TapGestureRecognizer）,滑动手势 （SwipeGestureRecognizer）是用于监测滑动的方向的，移动速度快,拖动手势（PanGestureRecognizer）是用于监测偏移的量的，移动速度慢,捏合手势（PinchGestureRecognizer）,旋转手势（RotationGestureRecognizer）,长按手势（LongPressGestureRecognizer）。注意:1.一个手势一般只能对应一个view，但同一个view可以添加多个手势;若要实现一个手势控制多个view，要实现其代理（UIGuidedAccessRestrictionDelegate）,把self作为代理设置给手势 longGesture.delegate = self;，并实现1234-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return YES;&#125;2.手势识别是互斥的，比如单击和双击，如果它识别出一种手势，其后的手势将不被识别。所以在添加手势时使用[A requireGestureRecognizerToFail：B]函数，它可以指定当A手势发生时，即便A已经滿足条件了，也不会立刻触发，会等到指定的手势B确定失败之后才触发。1234567891011121314151617181920212223242526272829303132333435363738//点击手势UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapAction:)];//点击次数设置tapGesture.numberOfTapsRequired = 2;//点击手指数目设置tapGesture.numberOfTouchesRequired = 1;//添加手势到目标view上面[self.blueVIew addGestureRecognizer:tapGesture];//滑动手势,一个手势只能控制一个方向UISwipeGestureRecognizer *swipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(swipeAction:)];//设置滑动方向direction方向// swipeGesture.direction = UISwipeGestureRecognizerDirectionLeft;//左// swipeGesture.direction = UISwipeGestureRecognizerDirectionRight;//右// swipeGesture.direction = UISwipeGestureRecognizerDirectionUp;//上swipeGesture.direction = UISwipeGestureRecognizerDirectionDown;//下//手指数swipeGesture.numberOfTouchesRequired = 1;//加到view上[self.yellView addGestureRecognizer:swipeGesture];//拖动手势UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panAction:)];[self.blueVIew addGestureRecognizer:panGesture];//捏合手势UIPinchGestureRecognizer *pinGesture = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(pinAction:)];[self.view addGestureRecognizer:pinGesture];//旋转手势UIRotationGestureRecognizer *rotationGesture = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(rotationAction:)];[self.view addGestureRecognizer:rotationGesture];//长按手势UILongPressGestureRecognizer *longGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(longGesture:)];//设置最短长按时间longGesture.minimumPressDuration = 1;[self.view addGestureRecognizer:longGesture];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIView","date":"2017-03-14T06:47:32.000Z","path":"2017/03/14/UIView/","text":"将一个view加到最上层如果想让一个页面显示在一直显示在最上面就把它加到window上面12345678self.navigationController.navigationBar.backgroundColor = [UIColor blueColor]; self.tabBarController.tabBar.backgroundColor = [UIColor orangeColor]; //获取到window UIWindow *window = [UIApplication sharedApplication].keyWindow; UIView *view = [[UIView alloc] init]; view.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); view.backgroundColor = [UIColor redColor]; [window addSubview:view]; 常用属性方法12345678910111213141516171819202122232425262728293031//获得自己的父控件@property (nonatomic, readonly) UIView *superview;//获得自己的所有子控件对象@property (nonatomic, readonly, copy) NSArray *subviews;//控件的ID标识，父控件可以通过tag来找到对应的子控件@property (nonatomic) NSInteger tag;//控件的形变属性，可以设置平移，比例缩放，角度旋转等属性@property (nonatomic) CGAffineTransform *transform;//添加一个子控件- (void)addSubview:(UIView *)view;//使用这个方法添加的子控件会被塞到subviews数组的最后面//可以使用下面的方法调整子控件在subview数组中的顺序 // 将子控件view插入到subviews数组的index位置 - (void)insertSubview:(UIView *)view atIndex:(NSInteger)index; // 将子控件view显示到子控件siblingSubview的下面 - (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview; // 将子控件view显示到子控件siblingSubview的上面 - (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview; // 将子控件view放到数组的最后面，显示在最上面 - (void)bringSubviewToFront:(UIView *)view; // 将子控件view放到数组的最前面，显示在最下面 - (void)sendSubviewToBack:(UIView *)view;//从父控件中移除- (void)removeFromSuperview;//根据tag值找到控件- (UIView *)viewWithTag:(NSInteger)tag;//控件矩形框在父控件中的位置和尺寸(以父控件的左上角为坐标原点)@property (nonatomic) CGRect fram;//控件矩形框的位置和尺寸(以自己左上角为坐标原点，所以bounds的x、y一般为0)@property (nonatomic) CGRect bounds;//控件中点的位置(以父控件的左上角为坐标原点)@property (nonatomic) CGPoint center;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"本地音乐播放","date":"2017-03-14T06:26:41.000Z","path":"2017/03/14/AVAudioPlayer/","text":"播放本地音乐可以用 AVAudioPlayer12345678910//音频播放类@property (nonatomic, strong) AVAudioPlayer *player;//播放进度@property (weak, nonatomic) IBOutlet UIProgressView *playProgress;//音量滑块@property (weak, nonatomic) IBOutlet UISlider *volumeSlider;NSURL *url = [[NSBundle mainBundle] URLForResource:[NSString stringWithFormat:@&quot;%@.mp3&quot;,self.musicArray[index]] withExtension:nil]; self.player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil];每个AVAudioPlayer只能播放一个url对应的音乐,他虽然有url属性，但是是只读的，不能修改，只能在初始化时赋值1234567891011121314151617将音乐加载到缓冲区[self.player prepareToPlay];开始播放[self.player play];暂停播放（暂停后可以继续播放）[self.player pause];结束播放（结束后就不能继续播放了）[self.player stop];播放音量@property float volume;获取音乐时长@property(readonly) NSTimeInterval duration;获取当前播放时长@property NSTimeInterval currentTime;显示播放进度//通过音频播放时长的百分比,给progressview进行赋值;self.playProgress.progress = self.player.currentTime/self.player.duration;AVAudioPlayerDelegate12345678//播放结束时执行的动作- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer*)player successfully:(BOOL)flag;//解码错误执行的动作- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer*)player error:(NSError *)error;//处理中断的代码- (void)audioPlayerBeginInteruption:(AVAudioPlayer*)player;//处理中断结束的代码- (void)audioPlayerEndInteruption:(AVAudioPlayer*)player;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"iOS碎片","date":"2017-03-14T05:27:32.000Z","path":"2017/03/14/iOS碎片/","text":"UITabBar123456//去掉(覆盖)原生Tabbar的上横线和背景图[[UITabBar appearance] setShadowImage:[self createImageWithColor:[UIColor clearColor]]];[[UITabBar appearance] setBackgroundImage:[self createImageWithColor:[UIColor clearColor]]];//隐藏tabBar的代码vv.hidesBottomBarWhenPushed = YES; UITabBarButton⾥面显⽰什么内容,由对应子控制器的tabBarItem属性来决定有两种方式可以往UITabBarController中添加子控制器 123[tb addChildViewController:c1];tb.viewControllers=@[c1,c2,c3,c4];展示的顺序和添加的顺序一致 UITabBarItem属性1234@property (nonatomic, copy) NSString *title;//标题文字@property (nonatomic, retain) UIImage *image;//图标@property (nonatomic, retain) UIImage *selectedImage;//选中时的图标@property (nonatomic, retain) NSString *badgeValue;//提醒数字 UIScrollView处理scrollView偏移64像素问题,设置1self.automaticallyAdjustsScrollViewInsets = NO; NSUserDefaults使用NSUserDefaults对数据进行保存之后, 它保存到系统的时间是不确定的，会在将来某一时间点自动将数据保存到Preferences文件夹下面，如果需要即刻将数据存储，可以使用12NSUserDefaults *defaults=[NSUserDefaults standardUserDefaults];[defaults synchronize]; 获取程序根目录12345678910方法一：NSString *home = NSHomeDirectory();方法二：（建议使用如下方法动态获取）NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSUserDomainMask：在用户目录下查找YES：代表用户目录的NSDocumentDirectory：查找Documents文件夹拼接文件路径NSString *path = [doc stringByAppendingPathComponent:@&quot;abc.plist&quot;]; Plist12345678910加载plist数据NSBundle的作用：用来访问与之对应的资源包内部的文件，可以用来获得文件的全路径,一个NSBundle对象对应一个资源包（图片、音频、视频、plis等文件）项目中添加的资源都会被添加到主资源包中, [NSBundle mainBundle]关联的就是项目的主资源包 NSBundle *bundle = [NSBundle mainBundle]; // 利用mainBundle获得plist文件在主资源包中的全路径 NSString *file = [bundle pathForResource:@&quot;shops&quot; ofType:@&quot;plist&quot;]; 写入plist [_dataArray writeToFile:file atomically:YES]; 去除NavigationBar下面的线 1self.navigationController.navigationBar.barStyle = UIBaselineAdjustmentNone; 重写方法121.重写对象的-(void)description;方法，可以自定义NSLog输出。2.重写-(void)dealloc;方法，自定义销毁（要保证super dealloc是重写方法里的最后一句） NSArray121.componentsSeparatedByString:以给定的字符串将目标字符串切分成数组2.componentsJoinedByString:以给定字符串将数组合成一个字符串 NSString1234567891011121314151617181.isEqualToString:比较两个字符串的内容是否相同2.compare:将接收对象和传递过来的字符串逐一比较3.compare:options:不区分大小写的比较（NSCaseInsensitiveSearch:不区分大小写 NSLiteralSearch:进行完全比较，区分大小写NSNumericSearch:比较字符串字符个数）4.-(BOOL)hasPrefix:(NSString)aString:检查字符串是否以另一个字符串开头5.-(BOOL)hasSuffix:(NSString)aString: 检查字符串是否以另一个字符串结尾6.-(NSRange)rangeOfString:(NSString)aString:检查字符串里是否包含其他字符串7.-(void)appendString:(NSString)aString:添加字符串8.-(void)appendFormat:(NSString)format,…:添加字符串9.-(void)deleteCharactersInRange:(NSRange)aRange:从字符串中删去一段10.initWithContentsOfFile:encoding:error:打开指定路径上的文本，读取文件内容，并使用文件内容初始化一个字符串例：NSError *error =nil;NSString *string = [[NSString alloc] initWithContentsOfFile:@&quot;/tmp/wprds.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error];if(nil != error)&#123; NSLog(@&quot;%@&quot;,[error localizedDescription]);&#125; ** Staticstatic的作用：1.修饰局部变量让局部变量只初始化一次局部变量在程序中只有一份内存并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）2.修饰全局变量全局变量的作用域仅限于当前文件","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"Xcode工程配置","date":"2017-03-14T02:39:35.000Z","path":"2017/03/14/Xcode工程配置/","text":"查找Xcode里的iOS版本包路径1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 权限获取1234567891011添加一个属性，输入Privacy后就会出现自动提示:描述字符串自己随意填写就可以,但是一定要填写，不然会引发包无效的问题，导致上传打包后构建版本一直不显示。麦克风权限 - Microphone Usage Description - 是否允许此App使用你的麦克风？相机权限 - Camera Usage Description - 是否允许此App使用你的相机？相册权限 - Photo Library Usage Description - 是否允许此App访问你的媒体资料库？通讯录权限 - Contacts Usage Description - 是否允许此App访问你的通讯录？蓝牙权限 - Bluetooth Peripheral Usage Description - 是否许允此App使用蓝牙？语音转文字权限 - Speech Recognition Usage Description - 是否允许此App使用语音识别？日历权限 - Calendars Usage Description - 是否允许此App使用日历？定位权限 - Location When In Use Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据定位权限 - Location Always Usage Description - 我们需要通过您的地理位置信息获取您周边的相关数据","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"单例","date":"2017-03-14T02:30:14.000Z","path":"2017/03/14/单例/","text":"GCD方式123456789101112131415//ViewController类的单例（调用单例时直接调这个方法）+ (instancetype)sharedInstance&#123; static ViewController *singleton = nil; //是否存在的判断 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil] instantiateViewControllerWithIdentifier:@&quot;musicVC&quot;]; 或 singleton = [[ViewController alloc] init]; //自定义处理 &#125;); return singleton;&#125; 经典方式重写allocWithZone方法XXX.m1234567891011121314id _XXX(类名);//alloc方法的底层方法+(id)allocWithZone:(struct _NSZone *)zone&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [super allocWithZone:zone]; //其他自定义处理 &#125; &#125; &#125;&#125; XXX.h1+(instancetype)sharedXXX; XXX.m1234567891011+(instancetype)sharedXXX&#123; if(_XXX == nil) &#123;//保证只加一次锁，防止频繁加锁 @synchronized(self) &#123; if (_XXX == nil) &#123;//防止多次创建 _XXX = [[self alloc] init]; &#125; &#125; &#125; return _XXX;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIDynamic物理引擎","date":"2017-03-14T01:43:46.000Z","path":"2017/03/14/UIDynamic物理引擎/","text":"UIDynamic隶属于UIKit框架可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象(重力、弹性碰撞等现象)UIDynamic使用步骤：1.创建一个物理仿真器（顺便设置仿真范围）1UIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];//ReferenceView:仿真范围2.创建相应的物理仿真行为（顺便添加物理仿真元素）123456//重力行为UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems:@[self.blueView]];//Items:要进行行为的对象//碰撞检测行为UICollisionBehavior *collision = [[UICollisionBehavior alloc] initWithItems:@[self.blueView]];//将参照视图的边框转变为碰撞检测的边界collision.translatesReferenceBoundsIntoBoundary = YES；3.将物理仿真行为添加到物理仿真器中，开始仿真1[animator addBehavior:grvity]; UIDynamic提供了以下几种物理仿真行为:UIGravityBehavior — 重力行为UICollisionBehavior — 碰撞行为:为Item与边界以及Item之间添加碰撞效果。UISnapBehavior — 捕捉行为UIPushBehavior — 推动行为UIAttachmentBehavior — 附着行为UIDynamicItemBehavior — 动力元素行为:配置一些公用的属性，与其他的Dynamic Behavior共同配合 常用属性方法12345678910111213141516//属性@property (nonatomic, readonly) UIView* referenceView;//参照视图@property (nonatomic, readonly, copy) NSArray* behaviors;//添加到物理仿真器中的所有物理仿真行为@property (nonatomic, readonly, getter = isRunning) BOOL running;//判定animator中是否还有行为正在执行@property (nonatomic, assign) id &lt;UIDynamicAnimatorDelegate&gt; delegate;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）//方法- (void)addBehavior:(UIDynamicBehavior *)behavior;//添加指定的行为动画- (void)removeBehavior:(UIDynamicBehavior *)behavior;//移除指定的行为动画- (void)removeAllBehaviors;//移除所有的行为- (NSTimeInterval)elapsedTime;//行为执行的时间，需要注意的是如果我们对同一个行为进行添加和移除操作时，时间会累积。- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;//如果想要改变center或者transform必须调用这个方法 ,否则改变是无效的. //代理方法- (void)dynamicAnimatorWillResume:(UIDynamicAnimator *)animator;//add行为时调用- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator;//remove行为时调用","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"隐藏文件","date":"2017-03-10T09:28:44.000Z","path":"2017/03/10/隐藏文件/","text":"在Windows系统下 隐藏rar到jpg图片中去：1.把要隐藏的文件生成压缩包2.新建一个文本文件，写入代码：12copy /b 图片名.jpg+压缩包名.rar 生成的图片名.jpg 3.将文本文件后缀改为bat4.运行bat文件 取出隐藏的文件：将jpg改为rar，然后解压 12copy /b 1+2 3该代码是将1，2两个文件进行连接（可以合并mp3,txt,,,,多种格式）,合并完1是显示的格式","tags":[{"name":"其他","slug":"其他","permalink":"https://Misaka-NO10032.github.io/tags/其他/"}]},{"title":"UIScrollView","date":"2017-03-10T08:01:52.000Z","path":"2017/03/10/UIScrollView/","text":"属性1234567891011121314151617181920212223@property(nonatomic) CGPoint contentOffset; 表示UIScrollView当前显示的位置（其实就是内容左上角与scrollView左上角的间距值）@property(nonatomic) CGSize contentSize; 表示UIScrollView内容的尺寸@property(nonatomic) UIEdgeInsets contentInset; 这个属性能够在UIScrollView的4周增加额外的滚动区域，一般用来避免scrollView的内容被其他控件挡住@property(nonatomic) BOOL bounces;设置UIScrollView是否需要弹簧效果@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置UIScrollView是否能滚动@property(nonatomic) BOOL showsHorizontalScrollIndicator;是否显示水平滚动条@property(nonatomic) BOOL showsVerticalScrollIndicator;是否显示垂直滚动条@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled;是否设置分页显示 UIScrollViewDelegate滚动1234567891011121314滚动开始- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;滚动中。。。- (void)scrollViewDidScroll:(UIScrollView *)scrollView;滚动结束- (void)scrollViewDidEndDragging:(UIscrollView *)scrollView willDecelerate:(BOOL)decelerate;开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;减速停止- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;是否支持滑动至顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;滑动到顶部时调用该方法- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 缩放123456789101112缩放实现步骤:1. 设置UIScrollView的id&lt;UISCrollViewDelegate&gt; delegate代理对象2. 设置minimumZoomScale ：缩小的最小比例3. 设置maximumZoomScale ：放大的最大比例4. 让代理对象实现下面的方法，返回需要缩放的视图控件 - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;跟缩放相关的其他代理方法缩放开始的时候调用 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view正在缩放的时候调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView UIPageControl12345678910一共有多少页@property(nonatomic) NSInteger numberOfPages;当前显示的页码@property(nonatomic) NSInteger currentPage; 只有一页时，是否需要隐藏页码指示器@property(nonatomic) BOOL hidesForSinglePage;其他页码指示器的颜色@property(nonatomic,retain) UIColor *pageIndicatorTintColor;当前页码指示器的颜色@property(nonatomic,retain) UIColor *currentPageIndicatorTintColor;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIButton","date":"2017-03-10T07:09:01.000Z","path":"2017/03/10/UIButton/","text":"12345678获得按钮的文字- (NSString *)titleForState:(UIControlState)state; 获得按钮的文字颜色- (UIColor *)titleColorForState:(UIControlState)state;获得按钮内部的小图片- (UIImage *)imageForState:(UIControlState)state;获得按钮的背景图片- (UIImage *)backgroundImageForState:(UIControlState)state;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UITableView","date":"2017-03-10T06:56:37.000Z","path":"2017/03/10/UITableView/","text":"去掉多余的分割线1self.tableView.tableFooterView = [[UIView alloc] init]; 刷新12345678刷新全部数据[self.tableView reloadData];刷新索引[self.tableView reloadSectionIndexTitles];刷新某个Section[self.tableView reloadSections:(nonnull NSIndexSet *) withRowAnimation:(UITableViewRowAnimation)];刷新某行[self.tableView reloadRowsAtIndexPaths:(nonnull NSArray&lt;NSIndexPath *&gt; *) withRowAnimation:(UITableViewRowAnimation)];","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]},{"title":"UIResponder相关","date":"2017-03-10T02:48:15.000Z","path":"2017/03/10/UIResponder/","text":"UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events,如插入耳机调节音量触发的事件)。UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder,所以这些类都可以响应事件。1234567891011121314//下一个接收事件的响应者@property(nonatomic, readonly, nullable) UIResponder *nextResponder;- (nullable UIResponder*)nextResponder;//是否成为第一响应者@property(nonatomic, readonly) BOOL canBecomeFirstResponder;//default is NO- (BOOL)canBecomeFirstResponder;//default is NO- (BOOL)becomeFirstResponder;//是否能取消第一响应者@property(nonatomic, readonly) BOOL canResignFirstResponder;//default is YES- (BOOL)canResignFirstResponder;//default is YES- (BOOL)resignFirstResponder;//是否是第一响应者@property(nonatomic, readonly) BOOL isFirstResponder;- (BOOL)isFirstResponder; 触摸事件(Touch Events)12345678910//触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; //触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸中断- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//3D触摸- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1); 运动事件(Motion Events)123456//运动开始- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);//运动中断- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0); 远程控制事件(Remote Control Events）12//远程控制- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0); UITouch当用户用手指触摸屏幕时，系统会为每根手指创建一个与之关联的UITouch对象UITouch保存着跟手指相关的信息，比如触摸的位置、时间、阶段；当手指移动时，系统会更新与之相对应的UITouch对象，使之能够一直保存该手指即时的触摸位置1234- (CGPoint)locationInView:(UIView *)view;函数返回触摸点相对view这个视图的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置- (CGPoint)previousLocationInView:(UIView *)view;该方法返回了前一个触摸点相对view的值 UITouch属性12345678910//触摸所在的窗口@property (nonatomic, readonly, retain) UIWindow *window;//触摸所在的view@property (nonatomic, readonly, retain) UIView *view;//短时间内点击屏幕的次数，可根据tapCount判断单击、双击或更多点击@property (nonatomic, readonly,) NSUInteger tapCount;//记录了触摸事件产生或变化时的时间，单位 （秒）@property (nonatomic, readonly) NSTimeInterval timestamp;//当前触摸事件所处的状态@property (nonatomic, readonly) UITouchPhase phase; UIEventUIEvent：称为事件对象，记录事件产生的时刻和类型.每产生一个事件，就会产生一个UIEvent对象常见属性12345//事件类型@property(nonatomic, readonly) UIEventType type;@property(nonatomic, readonly) UIEventSubtype subtype;//事件产生的时间@property(nonatomic, readonly) NSTimeInterval timestamp; UIEvent还提供相应的方法可以获得在某个view上面的触摸对象（UITouch）12- (NSSet *)allTouches；//获得全部UITouch- (NSSet *)touchesForView:(UIView *)view;//获取view上的UITouch","tags":[{"name":"iOS","slug":"iOS","permalink":"https://Misaka-NO10032.github.io/tags/iOS/"}]}]